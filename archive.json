{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-06-22T02:01:37.803014+00:00",
  "repo": "SECtim/draft-wuertele-oauth-security-topics-update",
  "labels": [
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "editorial",
      "description": "Typos, formatting, and the like.",
      "color": "17E24A"
    },
    {
      "name": "Needs WG input",
      "description": "Issue needs input from OAuth WG",
      "color": "2D16D4"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOOKn4ys6utJzJ",
      "title": "Decide on a title",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/1",
      "state": "OPEN",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "Needs WG input"
      ],
      "body": "So far, I've put \"OAuth 2.0 Security Best Current Practice\" as the title, but it might make sense to use a different title to at least indicate that this is an extension of an existing document of that name.",
      "createdAt": "2025-03-19T09:29:09Z",
      "updatedAt": "2025-06-12T07:55:03Z",
      "closedAt": null,
      "comments": [
        {
          "author": "KevinLuo2000",
          "authorAssociation": "NONE",
          "body": "Based on the published BCP \"suites\" in https://datatracker.ietf.org/doc/bcp, a straightforward title would probably be \"Updates to OAuth 2.0 Security Best Current Practice\".\n\nHowever, if we use the general title format \"Updates to xxx\", we should consider what yet another BCP document under [BCP 240](https://datatracker.ietf.org/doc/bcp240/) would be like. \"Second Round of Updates to OAuth 2.0 Security Best Current Practice\" sounds weird.",
          "createdAt": "2025-06-12T01:19:03Z",
          "updatedAt": "2025-06-12T01:19:51Z"
        },
        {
          "author": "SECtim",
          "authorAssociation": "OWNER",
          "body": "I also thought about the \"Update to...\" title option, but came to the same conclusion - I think it's best we leave as-is for now and explicitly ask the WG for their opinion once we put out the first individual draft.",
          "createdAt": "2025-06-12T06:56:03Z",
          "updatedAt": "2025-06-12T06:56:03Z"
        },
        {
          "author": "KevinLuo2000",
          "authorAssociation": "NONE",
          "body": "Yes, I agree that we should ask WG for their opinion.\n\nWhat about changing the title to \"Updates to ...\" for now? I was just thinking that having the same title as the published RFC9700 might cause confusion, making people think that it's the same document, or that we are proposing to obsolete the original RFC or going to repeat the unchanged sections.",
          "createdAt": "2025-06-12T07:55:03Z",
          "updatedAt": "2025-06-12T07:55:03Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDOOKn4ys6utShA",
      "title": "Description for Audience Injection Attacks",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/2",
      "state": "CLOSED",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [
        "SECtim",
        "PedramHD"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2025-03-19T09:39:58Z",
      "updatedAt": "2025-03-24T16:07:13Z",
      "closedAt": "2025-03-24T16:07:12Z",
      "comments": []
    },
    {
      "number": 3,
      "id": "I_kwDOOKn4ys6utTBW",
      "title": "Description for attacks from mix-up reloaded work",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/3",
      "state": "CLOSED",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Exact title and structure to be discussed.",
      "createdAt": "2025-03-19T09:40:32Z",
      "updatedAt": "2025-06-16T07:38:31Z",
      "closedAt": "2025-06-16T07:38:31Z",
      "comments": []
    },
    {
      "number": 4,
      "id": "I_kwDOOKn4ys6vXR8L",
      "title": "What RFCs should this document update?",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/4",
      "state": "OPEN",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [
        "SECtim"
      ],
      "labels": [
        "Needs WG input"
      ],
      "body": "\"Update\" in the RFC \"updates\" list sense.\n\nWe certainly have 6749, 9700, and 6750 (due to the \"Mix-Up Reloaded\" issuer sharing cases, where a client ends up sending a bearer token to the wrong RS, thereby leaking it).\n\nProbably also 7521, 7522, and 7523 (or, at the very least, 7523).\n\nAnything else?",
      "createdAt": "2025-03-24T06:13:20Z",
      "updatedAt": "2025-04-05T05:36:24Z",
      "closedAt": null,
      "comments": [
        {
          "author": "SECtim",
          "authorAssociation": "OWNER",
          "body": "Probably also PAR",
          "createdAt": "2025-04-04T06:18:40Z",
          "updatedAt": "2025-04-04T06:18:40Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOOKn4ys6xHAmc",
      "title": "In 2.1, clarify why the token EP is used as aud",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/8",
      "state": "CLOSED",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [
        "SECtim",
        "PedramHD"
      ],
      "labels": [],
      "body": "Based on feedback by @adon-at-work to help readers",
      "createdAt": "2025-04-04T06:32:42Z",
      "updatedAt": "2025-04-28T14:05:34Z",
      "closedAt": "2025-04-28T14:05:33Z",
      "comments": []
    },
    {
      "number": 9,
      "id": "I_kwDOOKn4ys6xQcyD",
      "title": "Make the description of audience injection attacks more self-contained",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/9",
      "state": "OPEN",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [
        "SECtim",
        "PedramHD"
      ],
      "labels": [],
      "body": "(This is part of the feedback by @adon-at-work)\nAs a reader, it would be more readable if it's more self-contained, an engineer is unlikely to go read a full academic paper. (A number of places is referring to paper for details, which is for now a TODO deadlink, and that gave me a hard time. I\u2019m expecting the WG or those first time reader who aren't familiar with the work may have the same impression).",
      "createdAt": "2025-04-05T05:21:49Z",
      "updatedAt": "2025-04-05T05:21:49Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 10,
      "id": "I_kwDOOKn4ys6xQc7x",
      "title": "Clarify the description of the AS issuer identifier defense",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/10",
      "state": "CLOSED",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [
        "SECtim",
        "PedramHD"
      ],
      "labels": [],
      "body": "(This is part of the feedback by @adon-at-work)\n- 2.1.2.1 Reminder about validating issuer field from metadata file, as per [rfc8414#section-3.3](https://datatracker.ietf.org/doc/html/rfc8414#section-3.3). Reminder for not to extract issuer from the token_endpoint string (engineer may be tempted to do so given their current implementation).\n- 2.1.2.1 \u201c\u201dNote that \"issuer identifier\" here does not refer to the term \"issuer\" as defined in {{Section 4.4 of RFC9700}}, but to the issuer identifier as used in {{!RFC8414}} and {{OpenID.Discovery}}.\u201d\u201d What\u2019s the difference?",
      "createdAt": "2025-04-05T05:23:23Z",
      "updatedAt": "2025-04-28T13:59:03Z",
      "closedAt": "2025-04-28T13:59:03Z",
      "comments": []
    },
    {
      "number": 11,
      "id": "I_kwDOOKn4ys6xQdN-",
      "title": "Discuss \"single value audience\" requirements",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/11",
      "state": "OPEN",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [
        "SECtim",
        "PedramHD"
      ],
      "labels": [],
      "body": "(This is part of the feedback by @adon-at-work)\n2.1.2.2 aud=single target endpoint\n- single audience requirement. multiple audiences I think isn't necessarily a bad thing, as long as they are all belonging to the same issuer. ex. [[h-as.com/token](http://h-as.com/token), [h-as.com/revoke](http://h-as.com/revoke)]\n- What's the expectation if I need a cla for token negotiation and then later for revocation. I kinda think it could be a transactional process, I got a token, finish my task, and do clean up. I think it makes sense to reuse the same cla for both. But if its single aud, then i gotta create cla twice, one per endpoint. This can discourage people to cleanup/call revoke given the performance penalty (jti was introduced there for performance/replay reason).\n- let's say we want to allow multiple aud from the same issuer. or more generally, as is today, when people put multiple aud, what's one-time use of `jti`mean? is that one-time use per aud, or across all audiences. should we clarify?",
      "createdAt": "2025-04-05T05:26:13Z",
      "updatedAt": "2025-04-07T22:34:23Z",
      "closedAt": null,
      "comments": [
        {
          "author": "SECtim",
          "authorAssociation": "OWNER",
          "body": "> multiple audiences I think isn't necessarily a bad thing, as long as they are all belonging to the same issuer\n\nThat would require normative changes to the AS; i.e., the AS then MUST verify that it can identify with _all_ elements in the `aud` array before accepting a client assertion (or, maybe better: all elements must be endpoints of the AS). Not necessarily a reason to not include this proposal, but something to be aware of.\n\n> But if its single aud, then i gotta create cla twice, one per endpoint.\n\nOnly when using the \"exact endpoint\" audience defense, i.e., when no issuer identifier is available.\n\n> This can discourage people to cleanup/call revoke given the performance penalty (jti was introduced there for performance/replay reason).\n\nI wouldn't say that `jti` was introduced to enable replay - actually, quite the opposite: To (at least optionally) prevent replay. For example, the default for [OpenID Connect authentication JWTs](https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication) is \"These tokens MUST only be used once\". In the IETF world, the usual formulation is something like \"MAY use `jti` to ensure that JWTs are not replayed\", e.g., in [RFC7519](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.7), [RFC7521](https://datatracker.ietf.org/doc/html/rfc7521#section-5.1), [RFC7522](https://datatracker.ietf.org/doc/html/rfc7522#section-3), [RFC7523](https://datatracker.ietf.org/doc/html/rfc7523#section-3), and [RFC9449](https://datatracker.ietf.org/doc/html/rfc9449#name-dpop-proof-jwt-syntax).\n\n> let's say we want to allow multiple aud from the same issuer. or more generally, as is today, when people put multiple aud, what's one-time use of jti mean? is that one-time use per aud, or across all audiences. should we clarify?\n\nThat's a can of worms this document certainly should not open, because it has nothing to do with audience injection attacks or their mitigation.\nThat said, in my opinion, the original formulations around `jti` and JWT replay/reuse are somewhat unfortunate, because they end up saying \"do whatever you want\" (with the exception of OIDC, but that also leaves the door open to \"unless conditions for reuse were negotiated between the parties\"), instead of giving clear options with their respective pros and cons.\n\n---\n\nSo, to summarize what I think:\n- This document should definitely avoid talking about `jti` and JWT replay/reuse.\n- I am in principle open to discuss the possibility of allowing `aud` arrays, but at least for RFCs 7521, 7522, 7523, and 9126, as well as the OIDF specs OIDC, CIBA, FAPI 1.0, and FAPI 2.0, corresponding updates/drafts thereof do require single-valued audiences; so talking about multi-valued `aud`s here might confuse people.",
          "createdAt": "2025-04-05T08:18:13Z",
          "updatedAt": "2025-04-05T08:18:13Z"
        },
        {
          "author": "adon-at-work",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">  use jti to ensure that JWTs are not replayed\n\nSure. I should word it more carefully. I meant \"jti was introduced there for (trading off between) performance/replay reason\". Performance-critical applications may not want to use `jti`, where security-critical applications use `jti` to prevent replay.\n\nThere were (at least) two specs regarding `jti`\n- https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.7 says `jti` is optional, whereas\n- https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication says `jti` is required \n\nI missed the 2nd spec initially, and thought that most people aren't using `jti` since it's optional (given that replay is, to certain degree, mitigated by `exp` already). So I raised the concerns. \n\nSince `jti` is already a required thing in the context of using jwt as client authentication, then I assume people is likely re-generating a new cla fresh anyway whenever it hits an endpoint. So, I agree we should not bring up `jti`.",
          "createdAt": "2025-04-07T22:32:21Z",
          "updatedAt": "2025-04-07T22:34:22Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "I_kwDOOKn4ys6xQeXp",
      "title": "Clarify that proposed fixes do not require AS changes",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/12",
      "state": "CLOSED",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [
        "SECtim",
        "PedramHD"
      ],
      "labels": [],
      "body": "@adon-at-work's initial feedback includes:\n\n> Draft does NOT mention the need for AS server change. But the openid letter clearly spells it out.\n> - Should AS change its enforcement first (ex. accepting token endpoint today but some clients are presenting aud=issuer)? Or should clients go first? It\u2019s practically impossible to coordinate so many parties to agree on a change, even more unlikely to happen at the same time. Then people will naturally ask for backward compatibility.\n> - Think about the owner of the malicious AS, he will likely have no incentive to update\u2026 but will come up with all kinds of excuses like I can\u2019t update because I have no engineering resources\u2026 Will client still need to send token_endpoint to those not updating yet?\n\n=> Draft should state and explain why the \"aud = issuer identifier\" and \"aud = exact endpoint\" defenses do not require any AS changes.",
      "createdAt": "2025-04-05T05:30:03Z",
      "updatedAt": "2025-04-28T13:55:04Z",
      "closedAt": "2025-04-28T13:55:03Z",
      "comments": []
    },
    {
      "number": 13,
      "id": "I_kwDOOKn4ys6xQfO1",
      "title": "Discuss proposed alternative defense",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/13",
      "state": "OPEN",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [
        "SECtim",
        "PedramHD"
      ],
      "labels": [],
      "body": "(This is part of the feedback by @adon-at-work)\n\n> Easiest and most pragmatic solution that works overnight, that requires only client changes. Client ensures that there\u2019re no overlaps of client_id and token_endpoint pairs for all its ASes (be it existing ones or those by DCR in the future). Unlikely there\u2019s a legit use case where the pair would be the same across two different issuers. Should there be an existing collision, as a remedy, the app can re-register to get a new client_id over DCR from one of the issuers (the legit one is unlikely to reuse client_id) to make things unique.\n\nThink about whether this works and what the client has to watch out for. If viable as a defense, consider adding it.",
      "createdAt": "2025-04-05T05:33:18Z",
      "updatedAt": "2025-04-10T22:58:19Z",
      "closedAt": null,
      "comments": [
        {
          "author": "SECtim",
          "authorAssociation": "OWNER",
          "body": "Also consider ecosystems that always use the same client_id across ASs (e.g., OpenID Federation).",
          "createdAt": "2025-04-05T05:34:20Z",
          "updatedAt": "2025-04-05T05:34:20Z"
        },
        {
          "author": "SECtim",
          "authorAssociation": "OWNER",
          "body": "> requires only client changes\n\nThat is also true for the \"aud = issuer identifier\" and \"aud = exact endpoint\" defenses (see #12).\n\n> Client ensures that there\u2019re no overlaps of client_id and token_endpoint pairs for all its ASes\n\nI actually think that's not sufficient to prevent audience injection attacks, at least not in general. Consider a client that always includes the token and revocation endpoints in its client assertions (which is perfectly fine w.r.t. the relevant standards). In that case, the attacker AS can publish the following metadata (excerpt):\n```\ntoken_endpoint: att.com/token,\nrevocation_endpoint: hon.com/token\n```\nThe client's token request (to what the client thinks is the attacker AS) goes to `att.com/token` (i.e., to the attacker) and includes a client assertion with `aud: [\"att.com/token\", \"hon.com/token\"]`. That `aud` value is also valid for requests to `hon.com/token` (and maybe other endpoints of `hon.com` as well, see #8). Hence, this is an instance of an audience injection attack.\n\nWithout AS changes, most combinations of endpoints with client authentication can be (ab)used in one way or the other by an attacker to obtain a client assertion that's valid somewhere else _unless_ the client chooses an `aud` value that's either the issuer identifier or the exact target endpoint. Hence, I'd be very careful in trying to come up with some \"clever\" way for the client to ensure its AS registrations are \"not attackable\" (and, what's more: Any such requirement on the client would be in conflict with the current and widely implemented logic of \"client ID and AS endpoints are provided by the AS and (mostly) opaque values to the client\" with only very minimal restrictions, such as mandatory HTTPS for the token endpoint).\n\nAlso note that just doing another round of DCR - even if feasible, think of stuff like initial access tokens that are typically one-time use - is not at all guaranteed to result in a different client ID. In some cases, having the same client ID for all registrations of a given client (even across ASs) is mandatory, e.g., in OpenID Federation.\n\nI.e., I think this mechanism might introduce problems in practice and, more importantly, doesn't reliably work as a defense.",
          "createdAt": "2025-04-05T08:42:41Z",
          "updatedAt": "2025-04-05T08:42:41Z"
        },
        {
          "author": "adon-at-work",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with everything you said. \n\nBut as I emphasized, the alternative defense is a **quick-and-dirty** fix (and surely it comes with all those \"cleverness\" concerns here and there as you tried to enumerate...). \n\nThe fundamental difference between our believes may be that I assume a change to `aud=token_EP` will introduce backward compatibility issues, since most (or at least some) ASes accept `aud=token_EP` **only**, as influenced and suggested by many of those specs. But apparently, you seem to expect *all* ASes to readily take any values that identify themselves (could be issuer, token_EP, par_EP, etc, and so no AS change is needed). \n\nIf the assumption is right, there will be compatibility issue. So in this imperfect world, what can a client do to secure itself while still keeping the lights on when these \"standard-non-compliant\" servers will only accept \"aud=token_EP\"?\n\n> Without AS changes, most combinations of endpoints with client authentication can be (ab)used in one way or the other by an attacker to obtain a client assertion that's valid somewhere else unless the client chooses an aud value that's either the issuer identifier or the exact target endpoint.\n\nAgree. Multiple values in aud is asking for trouble.\n\nI see here you're implicitly expecting client to use a **single** aud value for your solution to be secured too. If a client uses the same client_id across all ASes and include all issuers in its `aud=[issuer1, issuer2]`, then it can be screwed too. \n\nSimilarly, the alternative fix is meant for a vulnerable client that uses a **single** `aud = token_EP`. If we want to generalize, it could be said as \"there\u2019re no overlaps of client_id and token_endpoint (or whatever values client use in the aud) pairs for all its ASes\". But of course, this discussion is meaningful only if you're convinced about the backward compatibility issue.",
          "createdAt": "2025-04-07T21:22:43Z",
          "updatedAt": "2025-04-07T22:03:37Z"
        },
        {
          "author": "SECtim",
          "authorAssociation": "OWNER",
          "body": "> fundamental difference between our believes\n\nI agree that we seem to have different believes \ud83d\ude04 \n\n> a change to aud=token_EP will introduce backward compatibility issues, since most (or at least some) ASes accept aud=token_EP only, as influenced and suggested by many of those specs. But apparently, you seem to expect all ASes to readily take any values that identify themselves (could be issuer, token_EP, par_EP, etc, and so no AS change is needed).\n\nMy take on this is twofold: First, the \"expectation\" that an AS will accept the exact target endpoint and its issuer identifier as `aud` is a normative requirement in all specs (that I am aware of) outside of the \"original culprits (OIDC, RFCs 752x)\" that do say something about the `aud` values an AS has to accept (RFC 9126 and CIBA) contain a sentence like: _\"the authorization server MUST accept its issuer identifier, token endpoint URL, or pushed authorization request endpoint URL as values that identify it as an intended audience.\"_ (quote is from the Pushed AuthZ Request RFC)\n\nSecond, in any case, I think we do agree that the current normative language around what `aud` values an AS is allowed to accept does not conflict with the proposed fixes, i.e., they do not require normative changes to the AS.\n\n> So in this imperfect world, what can a client do to secure itself while still keeping the lights on when these \"standard-non-compliant\" servers will only accept \"aud=token_EP\"?\n\nIf you as a client are willing to continue using an AS that\n1. Requires authentication at more than the token endpoint;\n2. Expects its token endpoint as the sole `aud` value at ALL these endpoints (keep in mind, for at least CIBA and PAR, an AS is _explicitly_ required to accept the respective exact endpoint as `aud`);\n3. Does not care enough about its clients' security to change what `aud` values it accepts; and \n4. Does not offer a way for you as a client to update your registered key material\n   1. Note 1: the current text explicitly mentions the possibility of using different key material for each AS as an alternative defense\n   2. Note 2: it is sufficient if the AS just allows the client to rotate their authentication public key, i.e., the AS does not need to support full-blown Dynamic Client Management or similar (and while not _required_ in any spec that I know of - albeit some specs like RFC 7591, OIDC, and OIDC DCR do explicitly mention key rotation, FAPI 2.0 SP \"recommends\" it - I think we can agree that not allowing key rotation is a red flag in the first place)\n\n... then yes, the currently proposed fixes cannot be applied to all communication with that particular AS.\nThat said, I'd argue that this is such a special case that it does not justify including a defense...\n- That will only work in this very particular special case (assuming that some other things are clarified, e.g., the handling of `mtls_endpoint_aliases`),\n- Relies on the AS continuing to only accept its token endpoint,\n- Should certainly NOT be used when any other defense is available,\n- Relies on the client not doing \"strange, but technically allowed\" things when talking to the attacker AS (like using the attacker AS' PAR endpoint as an `aud` value for requests to other endpoints of the attacker AS; note that it is the attacker who \"defines\" what it wants from the client, so if the client wants to talk to the attacker AS, it has to comply), and\n- Breaks currently allowed setups where multiple perfectly honest, standards-compliant ASs may share a token endpoint (probably not a _common_ case, but allowed nonetheless).\n\n... in a BCP update. Including a \"quick and dirty\" works-in-some-scenarios-but-not-in-others defense has huge potential for confusion - and I'd expect to then see clients implement this less-than-ideal defense, but never re-evaluating whether an actual fix can be deployed at a later time.\n\n> But of course, this discussion is meaningful only if you're convinced about the backward compatibility issue.\n\nAs of right now, I am not really convinced that backward compatibility will be a huge issue (see the enumeration of preconditions above). That said, I still see value in discussing, because I may of course overlook things.\n\n---\n\n> I see here you're implicitly expecting client to use a single aud value for your solution to be secured too.\n\nThat is not an implicit expectation, the current text very much explicitly says \"sole audience value\".\n\n> If a client uses the same client_id across all ASes and include all issuers in its aud=[issuer1, issuer2], then it can be screwed too.\n\nIf a client issues an assertion that is _intended_ (which is what `aud` expresses) to be valid at multiple ASs, then it shouldn't come as a surprise that this assertion _will_ be valid at (those exact!) multiple ASs - hence, I would not consider that an attack.\nThat said, _intending_ an authentication credential for multiple ASs (that the client generally has to assume will be issuing different client_ids) is a very strange choice by the client, albeit technically allowed (but will be forbidden by the proposed fixes, not only in this document, but also the proposed updates to RFCs 752x, OIDC, CIBA, ..., which I think is a good thing).\n\n> the alternative fix is meant for a vulnerable client that uses a single aud = token_EP.\n\nI am not sure what you're trying to say here - that the alternative fix is only meant for clients that use single-valued `aud`? For which AS(s)? Or something entirely different?",
          "createdAt": "2025-04-08T08:08:05Z",
          "updatedAt": "2025-04-08T08:08:05Z"
        },
        {
          "author": "adon-at-work",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Let's not go line by line about my previous response. With due respect, I disagree your counterexample serves to invalidate a quick-and-dirty fix, which is meant to be a quick and dirty fix.\n\n---\n\nMore importantly, as a reader from the engineering world, if I read OIDC (specifically [section 9](https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication) and may be also RFC752x), and implemented everything there with AS accepting **only** token EP (note that there're no such Updates/Deprecates header on OIDC docs), I'll be happily declaring that I'm fully standard-compliant. It's unlikely I'd go look at CIBA and RFC9126 (PAR) until there's a need to support those extensions.\n\nAnd if we read the whole passages from CIBA and RFC9126(PAR) in their entirety, they both recognized there's ambiguity on `aud` value, and thus backward compatibility issues. People can always say I gotta balance resources/risk among priorities other than just security. Putting myself into the shoes of the opposing side, some will likely argue that they're NOT a normative change anyone has to follow or have followed, since (1) they have no Updates/Deprecates header for the older RFC/OIDC; (2) they can be interpreted as extension-specific; (3) the last \"MUST\" sentence that you quoted is also a conditional statement applicable to those who need/want to facilitate interoperability; and/or (4) the last sentence from CIBA and RFC9126 sound kinda incompatible with each other if I need to support both CIBA and RFC9126. It doesn't mean/matter if I, as a security folk, fully agree, that's just how the world works. You will understand as you enter the industry. :)\n\nFrom [CIBA](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html#auth_request)\n\n> Note that there's some potential ambiguity around the appropriate audience value to use when JWT client assertion based authentication is employed. To address that ambiguity the Issuer Identifier of the OP SHOULD be used as the value of the audience. To facilitate interoperability, the OP MUST accept its Issuer Identifier, Token Endpoint URL, or Backchannel Authentication Endpoint URL as values that identify it as an intended audience.\n\nFrom [RFC9126](https://datatracker.ietf.org/doc/html/rfc9126#section-2-5)\n\n> Due to historical reasons, there is potential ambiguity regarding the appropriate audience value to use when employing JWT client assertion-based authentication (defined in [Section 2.2](https://www.rfc-editor.org/rfc/rfc7523#section-2.2) of [[RFC7523](https://datatracker.ietf.org/doc/html/rfc7523)] with private_key_jwt or client_secret_jwt authentication method names per Section 9 of [[OIDC](http://openid.net/specs/openid-connect-core-1_0.html)]). To address that ambiguity, the issuer identifier URL of the authorization server according to [[RFC8414](https://datatracker.ietf.org/doc/html/rfc8414)] SHOULD be used as the value of the audience. In order to facilitate interoperability, the authorization server MUST accept its issuer identifier, token endpoint URL, or pushed authorization request endpoint URL as values that identify it as an intended audience.\n\nMy two cents. May be I'm wrong, BCP is BCP, technically it's not a standard. No matter what will be written, people might have different opinions on considering anything there as normative changes or not. Regardless, your contribution on writing up a useful BCP is valuable, if possible, take the chance to cleanup the mess. Give a comprehensive guide on how things can be best fixed, and leave no/less ambiguity so people can have excuses. And that's my perhaps naive belief. :)\n\nAnd so, just as a random reader (who'd appreciate a well-documented reference to use against Goliath :)), I'd love to see:\n- at least recognize the ambiguity like CIBA/RFC9126, so people know a client change from token_EP to something else may be a breaking change, since it does not guarantee server acceptance. If it just works, cool!\n- the BCP / most recommended `aud` value a client should send. conforming to CIBA and RFC9126, apparently should be the issuer.\n- the BCP for AS, what `aud` value should it accept? regardless of whether it's interpreted as normative or just a BCP recommendation. You probably want AS to accept only either issuer or target-specific endpoint URL. I'd argue making it target endpoint specific is never clearly spelled out by any other spec. For instance, PAR endpoint should not take aud=token_EP, and token_endpoint should not take aud=par_EP, unless for interoperability/historical reasons.\n- the BCP if just in case a client cannot get all your ASes to comply, then there comes recommendations in decreasing preference. 1. use different (the current draft uses the word \"fresh\") key material per AS; 2. ensure no overlapping of (client_id, aud) among all supported current and future ASes (unless absolutely required... it's okay to condition that), etc...\n\nThey're my little suggestions for you to consider and decide one way or the other. Thanks and appreciate that. :)",
          "createdAt": "2025-04-09T18:58:38Z",
          "updatedAt": "2025-04-10T22:58:19Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "I_kwDOOKn4ys6zhnK0",
      "title": "Make \"Updates to Mix-Up Attacks\" subsection more self-contained",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/18",
      "state": "CLOSED",
      "author": "KevinLuo2000",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "(This is part of the feedback by @adon-at-work on #17, to be resolved by @KevinLuo2000)\n\n> My first impression after reading the first few sections in 2.2 is like it\u2019s written more like attacking RFC9700 4.4 line by line or as if presenting a diff for D Fett\u2019s considerations of updating his spec than targeting someone who has no knowledge about mix-up. The fact that I need to open two specs side-by-side will fail to gain any tractions from engineers IMO. The spec should be much more self-contained, and the requirements to click on a link is optional. It is extremely hard to follow, even for me. \n>\n> This new RFC draft implies that we\u2019re no more in the mentality of filing an errata to RFC9700 nor making last minute modification suggestions before RFC9700 was published. Your section 2.3 seems to be starting fresh with a new attack (even claiming a huge scope, as huge as \u201cAttacks in open ecosystems\u201d), which is good.",
      "createdAt": "2025-04-22T19:26:26Z",
      "updatedAt": "2025-06-12T03:06:22Z",
      "closedAt": "2025-06-12T02:47:01Z",
      "comments": [
        {
          "author": "KevinLuo2000",
          "authorAssociation": "NONE",
          "body": "I kept the section title in 2.2 as \"Updates to Mix-Up Attacks\", but changed the first subvariant of the Per-AS Redirect URIs mix-up (\u201cAdvanced Mix-up Attacks\u201d) from a diff to RFC9700 4.4 to a self-contained description.\n\nAlso explicitly mentioned the names of two existing defenses to improve readability.\n\nSee commit https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/pull/17/commits/fce5556d69f31ee8a00c6c100499d8e4cb4b0b27 and https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/pull/17/commits/c01aa2d173edc62229a8fc1abb8d076240b507e4.",
          "createdAt": "2025-06-12T02:43:11Z",
          "updatedAt": "2025-06-12T03:06:22Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "I_kwDOOKn4ys6zhwVk",
      "title": "Clarify the application scenario and attack scenario of \"Open Ecosystems\"",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/19",
      "state": "OPEN",
      "author": "KevinLuo2000",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "(This is part of the feedback by @adon-at-work on https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/pull/17, to be resolved by @KevinLuo2000)\n\n**Condense Section 2.3.1 \"OAuth in Open Ecosystems\" and Section 2.3.2 \"Attack Scenario\":**\n\n> More generally, quite many content isn\u2019t written like a spec, but more like a blog/paper/story, and it will surprise those who come for a very cold BCP or a spec. Whether it\u2019s traditional/new, less barrier, and how open is irrelevant from spec perspective, they\u2019re more like market trends or just considerations for evaluating security risk/impact only. A link to perhaps a blog for such content (or a presentation talking about reversal) could be good, but they shouldn\u2019t be the main text of the spec. Those information, if absolutely relevant, should be compressed no more than 1 paragraph. I\u2019m afraid the more content you have, the harder it is to get consensus with a broad community. My point is less is better when drafting up the spec.\n\n**Clarify the scope of \"Open Ecosystems\":**\n\n> I have to also admit that I have a different opinion on DCR. May be I should not accuse it with \u201cno body using it\u201d or \u201cimpractical\u201d, when I lately figured the open-banking standard backed by UK gov has DCR standardized (99% similar to OAuth2 DCR as I briefly overviewed). Think about there\u2019s a universal banking app that works across all different (UK) banks. I assume a user can just go to such a universal banking app, choose let\u2019s say HSBC (which under the hood hits HSBC\u2019s DCR) or even directly specify any URL that conforms to the UK open-banking standard. Then the client negotiates some client credential for oauth client authentication, and subsequently launches auth code grant to authenticate the user too. \n> \n> I don\u2019t know whether we should classify it as open-ecosystem, where the app will then speak the same standardized banking protocols regardless of what bank resource servers are. May be they can support bank/issuer-sharing oauth scenarios since even a single user can have multiple bank accounts with a single bank. But it does have certain openness where a user can dynamically feed a new OAuth \u201cclient-configuration\u201d at will, and can face COAT attacks. \n> \n> I don\u2019t know how widely adopted that thing is, may be there\u2019s just some part of the world in EU we don\u2019t know enough. Let\u2019s just assume this existed, or may hypothetically exist in the future as a properly valid use case. Hence, I want AS-sharing to be described just as a characteristic by itself, instead of tiring it to and put it under a section of open-ecosystem. \n> \n> One line on AS-sharing, I think, is good and succinct enough to bring up the problem:\n> > AS-sharing. a client can use a (honest) AS, with multiple sets of different client credentials (e.g.., client id), for legitimate purposes.\n> \n",
      "createdAt": "2025-04-22T19:46:12Z",
      "updatedAt": "2025-06-12T05:29:19Z",
      "closedAt": null,
      "comments": [
        {
          "author": "KevinLuo2000",
          "authorAssociation": "NONE",
          "body": "I have kept the \u201copen ecosystem\u201d terminology and structure, as I do think it better motivates the issuer-sharing mix-up setup and the client configuration confusion attack. With all the recent developments in MCP and reflection on integration platforms, I feel the open ecosystem concept needs a special call-out.\n \nTo that end, I also generalized the \u201copen ecosystem\u201d definition to make it less specific to Integration Platforms.\nSee https://kevinluo2000.github.io/TestIETF/draft-wuertele-oauth-security-topics-update.html#name-oauth-in-open-ecosystems.\n ",
          "createdAt": "2025-06-12T03:10:20Z",
          "updatedAt": "2025-06-12T05:29:19Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOOKn4ys6zhycn",
      "title": "Decide whether to include \"Client Configuration Confusion\"",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/20",
      "state": "OPEN",
      "author": "KevinLuo2000",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "(This is part of the feedback by @adon-at-work on #17, to be resolved by @KevinLuo2000)\n\n> I don\u2019t have a good idea how 2.3.4 should be structured, but I\u2019m very afraid that may stir up more debate as one may argue it shouldn\u2019t be as an OAuth protocol issue. For argument sake, it\u2019s more a resource server issue, or more like an issue of \u201copen-ecosystem\u201d where access token is given to a resource endpoint controlled by attacker. I want it in, as 2.3, like a section of its own, as I think it\u2019s valuable to the community, but hesitate that people might not be very receptive, and it may take a lot more battles to fight that section in.\n",
      "createdAt": "2025-04-22T19:51:03Z",
      "updatedAt": "2025-06-15T07:04:18Z",
      "closedAt": null,
      "comments": [
        {
          "author": "KevinLuo2000",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> For argument sake, it\u2019s ... more like an issue of \u201copen-ecosystem\u201d where access token is given to a resource endpoint controlled by attacker.\n\nExactly. That's why I'd rather fit the section under the umbrella of \"Attacks in Open Ecosystems\".\n\nFurthermore, when the resource server URL can be specified at runtime, the threat is called out in RFC9700 Section 4.9.1 ([Access Token Phishing by Counterfeit Resource Server](https://datatracker.ietf.org/doc/html/rfc9700#name-access-token-phishing-by-co)), with defenses mentioned by Section 4.9.3 ([Countermeasures](https://datatracker.ietf.org/doc/html/rfc9700#name-countermeasures-8)) such as making access tokens sender-constrained and audience-restricted.\n\n> it\u2019s more a resource server issue\n\nI would say although our \"Client Configuration Confusion\" is Resource Server-related, it is complementary to the aforementioned threat and defense.\n* Threat-wise, we focus on reusing registered clients of an honest AS to exfiltrate access tokens, when the client has no intention of leaking the registered client's tokens to an attacker-controlled resource server.\n* Defense-wise, sender-constrained and audience-restricted tokens are sort of like defense-in-depth, while the defense for client configuration confusion is a specific security measure to resolve issues in open ecosystems.",
          "createdAt": "2025-06-12T03:23:28Z",
          "updatedAt": "2025-06-12T13:41:49Z"
        },
        {
          "author": "KevinLuo2000",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Related issues: #22 , #23 .",
          "createdAt": "2025-06-15T07:04:18Z",
          "updatedAt": "2025-06-15T07:04:18Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "I_kwDOOKn4ys6zh1Kx",
      "title": "Restructure \"Mix-up Reloaded\"-related Sections",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/21",
      "state": "OPEN",
      "author": "KevinLuo2000",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "(This is part of the feedback by @adon-at-work on #17, to be resolved by @KevinLuo2000)\n\n> With due respect, I recommend the following structure, with contents from 2.3.3 absorbed in appropriate sections.\n> \n> I suppose we should write it as a new attack, either we call it Advanced Mix-up Attacks (if you want to honor D Fett) or COAT and CORF Attacks, or even COAT and CORF (aka. Advanced mix-up). As you introduce it, may be we should just say this section 2.2 supersedes mix-up as defined in RFC9700 and/or we should frame there\u2019re n variants, and certain variants is covered by RFC9700.\n> \n> **2.2.1 Attack Description**\n> \u201cThe description here follows RFC9700 section 4.4 (kinda give credit to them), with new variants of the attack outlined below.\u201d\n> \n> Preconditions:\n> * copy presumptions that are still valid, probably we will use only the first one in 4.4\n> * **AS-sharing. a client can use a (honest) AS, with multiple sets of different client credentials (e.g.., client id), for legitimate purposes.** (RFC9700 implicitly assumed/implied otherwise. Just in case a client can guarantee uniqueness of AS, RFC9700 4.4 suffices\u2026 I assume this is true. If not, we may point to a discussion section.)\n> A final paragraph like \u201cHence this advanced mix-up requires less assumptions than the mixup in RFC9700.\u201d\n> And so we split the discussion into 2 subsections\n> \n> **2.2.1.1 Same redirect_uri**\n> Same as 4.4.1 + redirect_uri in the attack steps\n> Variants:\n> * Mix-Up with Interception. (same as 4.4.4.1) still copy their text\n> * Implicit Grant(same as 4.4.4.1) still copy their text\n> * OpenID Connect(same as 4.4.4.1) still copy their text\n> * Na\u00efve\u2026 or CORF (new)\n> * Whatever other new variant\n> \n> **2.2.1.2 Distinct redirect_uri**\n> Open this paragraph with why it can still fail, as opposed to understanding in RFC9700.\n> Same as 4.4.1 with distinct redirect_uri adjusted accordingly in attack steps\n> \n> Variants:\n> * Mix-Up with Interception. refer to 2.2.2.1\n> * Implicit Grant. refer to 2.2.2.1\n> * OpenID Connect. refer to 2.2.2.1\n> * Inherit other in 2.2.2.1\n> * Add any new, if any\n> \n> (new and old) Variants corresponding and unique to distinct redirect_uri.\n> \n> **2.2.2 Countermeasures.**\n> 2.2.2.1\n> When precondition 2 does not hold, or when client has enforced that the AS-sharing condition will NOT exist. One may refer to 4.4.2, except with the following cavets/updates\u2026\u2026 this is basically your draft. But please make those suggested defenses split also in bullet form that kinda correspond to Variant list (better if you can come up with a name for them instead of Variant 1,2,3).\n> \n> 2.2.2.2\n> Given precondition 2, 2.2.1.1 needs to change to use distinct redirect_uri, right?",
      "createdAt": "2025-04-22T19:56:57Z",
      "updatedAt": "2025-06-13T01:15:30Z",
      "closedAt": null,
      "comments": [
        {
          "author": "KevinLuo2000",
          "authorAssociation": "NONE",
          "body": "> AS-sharing. a client can use a (honest) AS, with multiple sets of different client credentials (e.g.., client id), for legitimate purposes. (RFC9700 implicitly assumed/implied otherwise. Just in case a client can guarantee uniqueness of AS, RFC9700 4.4 suffices\u2026 I assume this is true. If not, we may point to a discussion section.)\n\nI agree, but there maybe some misunderstandings here. Let me clarify:\n\n**On AS-sharing:**\n* If a client can guarantee uniqueness of AS, as you said, RFC9700 4.4 suffices, which is true.\n* If a client cannot guarantee uniqueness of AS, my claim is, RFC9700 4.4 still suffices (though there is an alternative) in defense (4.4.2), but needs clarifications on the attack descriptions (4.4.1). \n\n----\nFor **attack descriptions** (4.4.1), there are some ambiguities in the texts:\n> Preconditions: For this variant of the attack to work, it is assumed that\n> ...\n> * **the client stores the authorization server chosen by the user** in a session bound to the user's browser and uses the same redirection URI for each authorization server.\n\n> Attack on the authorization code grant:\n> ...\n> 2. **The client stores in the user's session that the user selected \"A-AS\"** and ...\n\nImplementers may argue that, \"storing the _authorization server_ chosen by the user\" will break the functional requirement of tracking issuer-sharing client configurations (e.g., sending the correct client credentials to the token endpoint). In other words, for a client to distinguish issuer-sharing client configurations, it cannot (just) store the \"authorization server\" chosen by the user, but should (also) store the \"client configuration\". Thus, the attacks in scenarios with shared issuers are simply out of scope of RFC9700 4.4.1, since the preconditions do not hold.\n\nThis is the confusing part with the attack description. I tried to clarify it in https://kevinluo2000.github.io/TestIETF/draft-wuertele-oauth-security-topics-update.html#name-attack-description-2.\n\n\n----\nWhen it comes to **countermeasures** (4.4.2), however, I would argue that 4.4 is sufficient.\nThe defenses in 4.4.2 requires the client to track each issuer (in a session), and compare with the returned issuer. The defenses do work for issuer-sharing client configurations, because the issuer bind authorization and token endpoints, leaving no room for the infiltration of a malicious endpoint. A client supporting issuer-sharing client configurations can, store the client configuration chosen by the user (for functional needs), and, at the same time, store and compare the returned issuer (for mix-up defense).\n\nTherefore, I suggested the \"distinct redirect_uri per client configuration\" defense as an _alternative_ to issuer-based defenses. See https://kevinluo2000.github.io/TestIETF/draft-wuertele-oauth-security-topics-update.html#name-countermeasures-2.\n",
          "createdAt": "2025-06-13T01:08:44Z",
          "updatedAt": "2025-06-13T01:15:30Z"
        },
        {
          "author": "KevinLuo2000",
          "authorAssociation": "NONE",
          "body": "**Structure:**\n> 2.2.1 Attack Description\n> 2.2.1.1 Same redirect_uri\n> 2.2.1.2 Distinct redirect_uri\n\nWhile same/distinct redirect_uri do relate to the attack preconditions, IMHO it is not a decisive factor in mix-up, thus I'd rather not treat it as a top-level separation in the attack description. Also, the \"distinct\" term alone can be unspecified since there are distinct per _issuer_ and distinct per _client configuration_. \n\n\n> 2.2.2 Countermeasures.\n> 2.2.2.1\n> When precondition 2 (AS-sharing) does not hold\n> 2.2.2.2\n> Given precondition 2 (AS-sharing), ...\n\nI agree with the separation here. I think AS/issuer-sharing should be the decisive factor in defense, and also the attack description. \n- Old World - No issuer-sharing: RFC9700 Section 4.4 + https://kevinluo2000.github.io/TestIETF/draft-wuertele-oauth-security-topics-update.html#section-2.2 .\n- New World - With issuer-sharing (Commonly seen in Open Ecosystems): https://kevinluo2000.github.io/TestIETF/draft-wuertele-oauth-security-topics-update.html#section-2.3.3.",
          "createdAt": "2025-06-13T01:08:52Z",
          "updatedAt": "2025-06-13T01:08:52Z"
        },
        {
          "author": "KevinLuo2000",
          "authorAssociation": "NONE",
          "body": "**Clarification:**\n> 2.2.2.2\n> Given precondition 2, 2.2.1.1 (Attack Description - Same redirect_uri) needs to change to use distinct redirect_uri, right?\n\nNot really. With same redirect_uri, a client could:\n* store each client configuration in a session (to fulfill functional requirement), AND\n* store each issuer in a session (maybe associated with stored client configuration thus no need of extra storage in session), AND\n* match with returned issuer identifier following RFC9207 (to fulfill security requirement a.k.a. mix-up defense).\n\nThis can be done without changing to use distinct redirect_uri.",
          "createdAt": "2025-06-13T01:08:58Z",
          "updatedAt": "2025-06-13T01:12:14Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "I_kwDOOKn4ys67ldGt",
      "title": "Idea: Alternative defense for Client Configuration Confusion attack",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/22",
      "state": "OPEN",
      "author": "KevinLuo2000",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The current defense for Client Configuration Confusion attack ([Section 2.3.4.2](https://kevinluo2000.github.io/TestIETF/draft-wuertele-oauth-security-topics-update.html#section-2.3.4.2)) is to enforce redirect_uri distinction, so as to prevent a malicious client configuration from using a preregistered client_id at honest AS. This defense takes effect at runtime (i.e., at the authorization endpoint in OAuth flows), but a side-effect may arise at registration time if DCR is used. Thus we further require software_id distinction at DCR client registration request, specifically meant to resolve this caveat.\n\n\nIn a recent discussion, @adon-at-work suggested the following alternative defense: \n\nIf DCR is the only client authentication method supported by a client, distinct software_id per client configuration MUST be used in client registration requests. \n\nRationale: A different software_id would render a different software statement in DCR client registration request, thus a different client_id being returned in DCR response. When client_ids are distinct, this would make the threat analogous to phishing threats that register new clients at an honest AS, making it out of scope of this attack.\n\nNote: the reason why this alternative defense is only modeled for (pure) DCR is that, for the case of manual (reversed) registration, it is non-trivial and impractical for a client in production environment to block duplicate client_ids from registration.\n\n\nWe should think about if such alternative defense shall be incorporated into the spec.\nAlso, resolve #23 first, which could be a blocker.",
      "createdAt": "2025-06-15T06:21:46Z",
      "updatedAt": "2025-06-15T07:03:20Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 23,
      "id": "I_kwDOOKn4ys67lgse",
      "title": "On normative requirement of software_id",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/23",
      "state": "OPEN",
      "author": "KevinLuo2000",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In the current writing, the defense for client configuration confusion attack involves the following caveat (and its resolution):\n\n> When dynamic client registration is supported, **clients SHOULD also specify a different software identifier** (software_id) in client registration requests for each client configuration. This prevents client registration requests from being rejected by the authorization server when different redirection URIs are used, if the authorization server follows the excerpt of Section 5 of RFC7591 below:\n> > An authorization server could also refuse registration requests from a known software identifier that is requesting different redirection URIs or a different client URI.\n\n\nHere we are basically requiring a client software instance to have different software ids for different client configurations. Although this requirement is only meant for open ecosystems, it imposes a normative change to the definition of software_id in RFC7591, where \n> the **\"software_id\" SHOULD remain the same** for all instances of the client software.\n\nIs there a better solution?\n\nOr maybe, this is not conflicting with the normative requirement in RFC7591 at all, when justified like below:\nThe registered clients for different client configurations shall be treated as different client softwares, because it is not the clients or client developers, but external developers or end-users, that integrate a certain piece of client configuration. Furthermore, conceptually, each client configuration itself operates an OAuth (sub-)client, although they may coexist at the same (aggregated) client software, reusing its OAuth client codebase.\n\nHowever, this may require further clarification on the definition of client software, which is only a single sentence in RFC7591:\n> Client Software\n> Software implementing an OAuth 2.0 client.",
      "createdAt": "2025-06-15T06:45:51Z",
      "updatedAt": "2025-06-15T06:49:09Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 24,
      "id": "I_kwDOOKn4ys67lwvp",
      "title": "Discussion: Elaborating more on Na\u00efve RP Session Integrity Attack / CORF?",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/24",
      "state": "OPEN",
      "author": "KevinLuo2000",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, in [Section 2.2.1](https://kevinluo2000.github.io/TestIETF/draft-wuertele-oauth-security-topics-update.html#section-2.2.1-11), I lump \"Na\u00efve RP Session Integrity Attack\"/\"Cross-app OAuth Request Forgery\" (CORF) under mix-up variants (specifically, under the \"Per AS Redirect URIs\" variant), since the general attack scenario and defense are the same as mix-up/\"Cross-app OAuth Request Forgery\" (COAT).  \n\nDo we need to expand its attack description to elaborate on the attack steps?\n\nOr maybe, should we separate out the attack to a standalone (sub)section, in parallel to mix-up attacks? Since the attack goal is not to obtain an authorization code or access token (i.e., Account Takeover, as in other mix-up variants), but to force the client to use an attacker's authorization code or access token for H-AS (i.e., Login CSRF/Forced Account Linking).\n\nGenerally, I think the attack requires a call-out, but not at the same level as mix-up. Fitting it under \"Per-AS Redirect URIs\" mix-up variants makes sense logically (3 subvariants, each with slightly differed attack assumptions). I also added a note highlighting the distinction in attack goals.\n\nSo personally I'm satisfied with the current shape.",
      "createdAt": "2025-06-15T08:18:37Z",
      "updatedAt": "2025-06-15T08:22:48Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 25,
      "id": "I_kwDOOKn4ys67mUTJ",
      "title": "Decide on a name for \"Client Configuration Confusion Attack\"",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/25",
      "state": "OPEN",
      "author": "KevinLuo2000",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Alternative Names: RS Mix-up / RS Confusion / AS-RS Mix-up / AS-RS Confusion. \n\nAny better ideas?\n\n\n**IMHO, the current name \"Client Configuration Confusion Attack\" best captures the gist of the attack.** Because the attack is not really mixing up RSes (RS mix-up/confusion) or simply pairing an AS with an unintended RS (AS-RS mix-up/confusion). \n\nDissecting the name \"Client Configuration Confusion Attack\":\n* It's one \"_client configuration_\", as a whole, can reuse the established client registration (aka registered client) at another client configuration, thus breaking the isolation boundary of client configuration, which is the \"_confusion_\" part.\n* To abuse this setup, we consider the case where the client configuration is attacker-controlled, who can specify a malicious RS to be paired with an honest AS where the client already has an established client_id (under an honest client configuration). The goal would be leaking honest AS' tokens, which is the \"_attack_\" part.\n\n---\nTo clarify, this attack is motivated by:\n* the setting of open ecosystems (where shared authorization server/issuer and attacker-controlled client configuration is possible), and\n* the fact that registering a new client is sometimes considered a privileged operation (with the corresponding attack mere consent phishing), and there's usually silent authorization configured at AS side when authorizing client_id with prior consent.\n-> therefore the attack's focus is on reusing registered client_ids.",
      "createdAt": "2025-06-15T11:26:10Z",
      "updatedAt": "2025-06-15T11:38:51Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 26,
      "id": "I_kwDOOKn4ys67rzny",
      "title": "Definition of \"Open Ecosystem\"",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/26",
      "state": "OPEN",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Continue the discussion from #17 \n\n---\n\n> It might be helpful for readers to explicitly say something along the lines of \"in what we refer to as open ecosystems, the registration roles are reversed: ...\" at the beginning of that paragraph.\n...\nIs there a good reason to not define \"open ecosystems\" via the \"reversed registration\" characteristic?\n\nThanks for the question! I'd say the intended generalizability of the spec may influence how we adjust the language.\n\nI did not define \"open ecosystems\" using the \"reversed registration\" characteristic because:\n\n* Two open ecosystem patterns:\n  - For Integration Platforms (the focus of our research paper), the \"reversed registration\" pattern makes perfect sense. The AS/RS, as external developers of the integration platform, proactively registers at the client, which is a reverse direction compared with ordinary OAuth deployments.\n  - However, in the spec, I also want to be less restrictive, and incorporate another possible open ecosystem pattern, that is gaining popularity in the AI Agent space (e.g., within the MCP protocol). In this case, the \"openness\" in the ecosystem stems not from external developers, but from end-users, who can enter ANY AS/RS's urls, and make the client interact with them.\n  - AFAIK, the \"reversed registration\" characteristic does **not** apply to this second case, since the AS/RS is still passively waiting for a non-reversed registration. \n* Nuance between \"registration\" and \"integration\":\n  - I also want to avoid overloading the term \"registration\", which in OAuth typically refers to client registration, i.e., the client already knows which AS it wants to contact, and goes register with the AS to obtain a client id and credential. What we're describing here is how the client decides which AS and RS to interact with, which I believe is better captured by the term \"integration\" rather than \"registration\".\n* On the term \"reversed\":\n  - I'm also unsure whether the term \"reversed\" might be a bit overloaded. If all AS/RS/Client registration information are manually provided (e.g., filled in as a form at the client's developer portal as in Integration Platforms), we could for sure confidently use the term \"reversed\". But if AS Metadata/PRM/DCR is used, then the AS Metadata/PRM/Client Registration Request shall be sent from the client to the AS/RS, which does not reflect the \"reversed\" pattern.\n\n\n----\nTo further explain my stance on the definition of open ecosystem, I'd like to reference the following RFCs:\n\nRFC8414 Authorization Server Metadata [Section 1](https://datatracker.ietf.org/doc/html/rfc8414#section-1):\n> The means by which the client chooses an authorization server is out\n   of scope.  In some cases, its issuer identifier may be **manually\n   configured** into the client.  In other cases, it may be **dynamically\n   discovered**, for instance, through the use of WebFinger [[RFC7033](https://www.rfc-editor.org/rfc/rfc7033)], as\n   described in [Section 2](https://www.rfc-editor.org/rfc/rfc8414#section-2) of \"OpenID Connect Discovery 1.0\"\n   [[OpenID.Discovery](https://www.rfc-editor.org/rfc/rfc8414#ref-OpenID.Discovery)].\n\n\nRFC9728 Protected Resource Metadata [Section 1](https://datatracker.ietf.org/doc/html/rfc9728#section-1-2):\n> The means by which the client obtains the location of the protected\n   resource is out of scope for this document.  In some cases, the\n   location may be **manually configured** into the client; for example, an\n   email client could provide an interface for a user to enter the URL\n   of their JSON Meta Application Protocol (JMAP) server [RFC8620].  In\n   other cases, it may be **dynamically discovered**; for example, a user\n   could enter their email address into an email client, the client\n   could perform WebFinger discovery [RFC7033] (in a manner related to\n   the description in Section 2 of [OpenID.Discovery]) to find the\n   resource server, and the client could then fetch the resource server\n   metadata to find the authorization server to use to obtain\n   authorization to access the user's email.\n\n\nOverall, rather than separating based on whether the AS/RS is \"manually configured\" or \"dynamically discovered\" (as above), I'd propose a different separation, based on _who_ integrates the AS and RS:\n- If it's the client or client developer, then it's a more trusted environment (unless you don't trust the client at all, which is a different story), because the client can solely decide which AS/RS to integrate based on its needs. This is what I referred to as the \"traditional OAuth deployments\".\n- If the integration is initiated by external developers or end-users, then it's a less trusted environment, because the client cannot, or at least is not the only party involved in making the integration decision. This is what I try to define as the \"open ecosystems\" pattern.\n\n----\n> I am not sure I agree with defining \"open ecosystems\" as below, because deciding what is accessible to a client is up to the **AS/RS/RO** in the traditional OAuth model as well.\n> > protected resources accessible to a client are configured beyond the discretion of the client or client developers\n\n\nI agree this is a bit confusing. Though I haven't found a satisfactory alternative yet.\n\n* If an **RO** (i.e., end-user) can decide what is accessible to the client, I guess it's more like the two examples in the RFC9728 Section 1 paragraph above. I think this case can fall under our definition of open ecosystems (similar to the MCP case).\n* If an **AS/RS** can decide what is accessible to a client, I guess we should further distinguish the nuance between \"expose\" and \"configure\":\n  - If the AS/RS's role is to decide whether to _expose_ a certain resource to a particular client (so that the resource can/cannot be accessible to the client), I would say this is orthogonal to what we try to define here. But we may need to clarify the language to avoid confusion.\n  - If the AS/RS's role is to decide whether to _configure_ itself at a particular client, I'd say this falls under our definition of open ecosystems (the Integration Platform case).\n\n----\n\nI've also touched up the language around \"client configurations\", so that the concept is not limited to open ecosystem, but also applicable to the traditional OAuth model. \n\nFeel free to let me know if the above explanations are helpful. We can work on the changes/discuss further in issues.\n\n_Originally posted by @KevinLuo2000 in https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/pull/17#discussion_r2149062904_\n            ",
      "createdAt": "2025-06-16T07:11:08Z",
      "updatedAt": "2025-06-16T07:11:46Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 27,
      "id": "I_kwDOOKn4ys67r5nj",
      "title": "Explicitly point out that issuer does not uniquely identify client config in open ecosystems",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/27",
      "state": "CLOSED",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Continue discussion from #17:\r\n\r\n---\r\n\r\nI see your point :thinking: My intention was to avoid confusion for readers and very explicitly point out that while the issuer does identify an AS, it does not (necessarily) uniquely identify a client configuration (in open ecosystems, which is the section this text is placed in).\r\n\r\nMaybe we can instead point that out the following paragraph, something like:\r\n\r\n> In open ecosystems, however, the new integration pattern does not, and fundamentally cannot, restrict the use of the same authorization server across multiple client configurations. For instance, clients may legitimately integrate various functionalities that access different resources or process the same resources differently, while relying on the same authorization server (i.e., having shared issuers **- therefore, the issuer no longer uniquely identifies a client configuration**).\r\n\r\n_Originally posted by @SECtim in https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/pull/17#discussion_r2149191728_\r\n            ",
      "createdAt": "2025-06-16T07:20:14Z",
      "updatedAt": "2025-06-16T11:03:08Z",
      "closedAt": "2025-06-16T11:03:08Z",
      "comments": []
    },
    {
      "number": 30,
      "id": "I_kwDOOKn4ys67w2nZ",
      "title": "Define attacker model for each attack",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/30",
      "state": "OPEN",
      "author": "KevinLuo2000",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\nThinking about this, maybe we should define what is the attacker model of our attacks in the respective attack section.\nReference:\nAttacker (A1) - (A5) in https://datatracker.ietf.org/doc/html/rfc9700#section-3.\n\n_Originally posted by @KevinLuo2000 in https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/pull/29#discussion_r2150083745_",
      "createdAt": "2025-06-16T14:00:47Z",
      "updatedAt": "2025-06-16T14:02:31Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 31,
      "id": "I_kwDOOKn4ys67yrZA",
      "title": "Reference RFC 9700 Attacker Model Where Applicable",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/31",
      "state": "CLOSED",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Thinking about this, maybe we should define what is the attacker model of our attacks in the respective attack section.\r\nReference:\r\nAttacker (A1) - (A5) in https://datatracker.ietf.org/doc/html/rfc9700#section-3.\r\n\r\n_Originally posted by @KevinLuo2000 in https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/pull/29#discussion_r2150083745_\r\n            ",
      "createdAt": "2025-06-16T16:38:30Z",
      "updatedAt": "2025-06-16T16:42:18Z",
      "closedAt": "2025-06-16T16:42:18Z",
      "comments": [
        {
          "author": "SECtim",
          "authorAssociation": "OWNER",
          "body": "Oops, duplicate of #30 - closing this.",
          "createdAt": "2025-06-16T16:42:18Z",
          "updatedAt": "2025-06-16T16:42:18Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "I_kwDOOKn4ys68RPqP",
      "title": "Phishing/audience mix-up mitigation",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/32",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This is somewhat related to the \"open systems\" section. See the full description on this issue on OAuth 2.1:\n\nhttps://github.com/oauth-wg/oauth-v2-1/issues/215",
      "createdAt": "2025-06-19T01:56:28Z",
      "updatedAt": "2025-06-19T11:07:31Z",
      "closedAt": null,
      "comments": [
        {
          "author": "KevinLuo2000",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @aaronpk ,\nThanks for reading our individual draft and pointing to the discussion in OAuth 2.1 issues!\n\n> This is somewhat related to the \"open systems\" section.\n\nYes, the attack described in the [OAuth 2.1 issue](https://github.com/oauth-wg/oauth-v2-1/issues/215) is related to the \"Client Configuration Confusion Attack\" specified in [Section 2.3.4 of our I-D](https://datatracker.ietf.org/doc/html/draft-wuertele-oauth-security-topics-update-01#section-2.3.4). Both involve an OAuth client in open ecosystem being tricked into sending an honest AS's access token to a malicious RS. (p.s. we followed your suggestion at OSW to define the [\"Client Configuration\" concept](https://datatracker.ietf.org/doc/html/draft-wuertele-oauth-security-topics-update-01#section-2.3.1-3), to better capture the context of this attack and the [mix-up variants](https://datatracker.ietf.org/doc/html/draft-wuertele-oauth-security-topics-update-01#section-2.3.3).)\n\n\nTheir differences lie in the attacker model and the defense:\n**Attacker Model.**\n- The attack in the OAuth 2.1 issue is a phishing attack that assumes a strong(er) attacker who can register the client at the honest AS, potentially due to open registration of DCR (i.e., no initial access tokens required). The attacker then uses the newly registered client at honest AS to pair it with a malicious RS.\n\n- The \"Client Configuration Confusion Attack\" in our I-D assumes a weaker attacker who cannot/finds it hard to register a new client, but is able to reuse the client registration of an honest client configuration. This could occur, for example, if a malicious MCP Server [is able to use the same `client_id`](https://datatracker.ietf.org/doc/html/draft-wuertele-oauth-security-topics-update-01#section-2.3.4.1.2) of an official Dropbox MCP Server that is plugged into the same MCP Client.\n\n**Defense.**\n- To defend against the threat described in OAuth 2.1 issue, I'd expect sender-constrained/audience-restricted tokens or alternative defenses discussed in the issue, which resolve the general threat of [access token misuse](https://www.rfc-editor.org/rfc/rfc9700#section-4.10). These defenses make perfect sense but require stringent Client/AS/RS cooperation to be compliant.\n\n- The defense for \"Client Configuration Confusion Attack\", however, is a specific security measure for the threat of reusing registered client in the weaker attacker model. And therefore, we wrote the following in the [defense section](https://datatracker.ietf.org/doc/html/draft-wuertele-oauth-security-topics-update-01#section-2.3.4.2-6):\n\n> This countermeasure can be considered an actionable approach to mitigating the \"Counterfeit Resource Server\" threat (see \"Access Token Phishing by Counterfeit Resource Server\" in [Section 4.9.1](https://rfc-editor.org/rfc/rfc9700#section-4.9.1) of [[RFC9700](https://www.rfc-editor.org/rfc/rfc9700)]) within the context of open ecosystems. **It is complementary to general defenses for access token misuses, such as sender-constrained and audience-restricted access tokens as specified in [Section 4.10](https://rfc-editor.org/rfc/rfc9700#section-4.10) of [[RFC9700](https://www.rfc-editor.org/rfc/rfc9700)]**.\n\nWe are open to further discussions on related threats.",
          "createdAt": "2025-06-19T11:07:30Z",
          "updatedAt": "2025-06-19T11:07:30Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 5,
      "id": "PR_kwDOOKn4ys6Pz3-x",
      "title": "Attack description for Audience Injection Attacks",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/pull/5",
      "state": "MERGED",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Closes #2 ",
      "createdAt": "2025-03-24T06:17:11Z",
      "updatedAt": "2025-03-24T16:07:12Z",
      "baseRepository": "SECtim/draft-wuertele-oauth-security-topics-update",
      "baseRefName": "main",
      "baseRefOid": "d698f037727d3a6d92acbbe4f763cb865c0cc9ad",
      "headRepository": "SECtim/draft-wuertele-oauth-security-topics-update",
      "headRefName": "aud_inj_attack_description_ph",
      "headRefOid": "05d09878a63bfc68461eb929a3722de5f8f1cf68",
      "closedAt": "2025-03-24T16:07:11Z",
      "mergedAt": "2025-03-24T16:07:11Z",
      "mergedBy": "PedramHD",
      "mergeCommit": {
        "oid": "150a5567dde5ecd6a4430b73ff294f5c853964f9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOOKn4ys6hkZs9",
          "commit": {
            "abbreviatedOid": "05d0987"
          },
          "author": "PedramHD",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-24T14:52:16Z",
          "updatedAt": "2025-03-24T14:52:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 6,
      "id": "PR_kwDOOKn4ys6P-9zB",
      "title": "Audience Injection Countermeasures",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/pull/6",
      "state": "MERGED",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [
        "PedramHD"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2025-03-25T06:11:32Z",
      "updatedAt": "2025-03-25T10:11:26Z",
      "baseRepository": "SECtim/draft-wuertele-oauth-security-topics-update",
      "baseRefName": "main",
      "baseRefOid": "150a5567dde5ecd6a4430b73ff294f5c853964f9",
      "headRepository": "SECtim/draft-wuertele-oauth-security-topics-update",
      "headRefName": "aud_inj_countermeasures_tiw",
      "headRefOid": "7f84fdc3550ad850b9c042bcc6ef65f7f04cd741",
      "closedAt": "2025-03-25T10:11:26Z",
      "mergedAt": "2025-03-25T10:11:26Z",
      "mergedBy": "PedramHD",
      "mergeCommit": {
        "oid": "8b07a975b10da6081d50b0b040adb3013e83ed4a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOOKn4ys6ht1-7",
          "commit": {
            "abbreviatedOid": "7f84fdc"
          },
          "author": "PedramHD",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-25T10:09:21Z",
          "updatedAt": "2025-03-25T10:09:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 7,
      "id": "PR_kwDOOKn4ys6QRyqR",
      "title": "minor touch up",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/pull/7",
      "state": "MERGED",
      "author": "adon-at-work",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I'm Adonis, one of the co-authors for the COAT and CORF work.\r\n\r\nThis audience injection attack is an interesting one. While reviewing what you guys have prepared for updating RFC9700, I spotted some non-controversial improvements as follows.\r\n\r\nI have other comments and questions regarding the attack and defense too, using my lens from both the academia and industry perspectives. I know Kaixuan is arranging a meeting between all of us, and we will discuss them. :)",
      "createdAt": "2025-03-26T22:17:10Z",
      "updatedAt": "2025-03-27T22:25:11Z",
      "baseRepository": "SECtim/draft-wuertele-oauth-security-topics-update",
      "baseRefName": "main",
      "baseRefOid": "8b07a975b10da6081d50b0b040adb3013e83ed4a",
      "headRepository": "adon-at-work/draft-wuertele-oauth-security-topics-update",
      "headRefName": "patch-1",
      "headRefOid": "1008401e47de198e0f5b080c7e8fbdedfa6588ec",
      "closedAt": "2025-03-27T22:12:39Z",
      "mergedAt": "2025-03-27T22:12:38Z",
      "mergedBy": "SECtim",
      "mergeCommit": {
        "oid": "63c6bb01cc01bc7cb4002846328ae57a267b8920"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOOKn4ys6iI6xa",
          "commit": {
            "abbreviatedOid": "982fa5c"
          },
          "author": "SECtim",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for taking the time to read through the proposed text and for improving it!",
          "createdAt": "2025-03-27T08:15:49Z",
          "updatedAt": "2025-03-27T08:16:49Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Unfortunately, this cannot be `json`, because that leads to errors in the build pipeline (complaining that this is not valid JSON, which is true). We consciously decided not to omit the `...`  to clearly indicate that further metadata is needed.",
              "createdAt": "2025-03-27T08:15:49Z",
              "updatedAt": "2025-03-27T08:17:11Z"
            },
            {
              "originalPosition": 14,
              "body": "See above.",
              "createdAt": "2025-03-27T08:15:57Z",
              "updatedAt": "2025-03-27T08:16:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOKn4ys6iUBmL",
          "commit": {
            "abbreviatedOid": "101491b"
          },
          "author": "SECtim",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-27T19:13:01Z",
          "updatedAt": "2025-03-27T19:13:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOOKn4ys6iUPPA",
          "commit": {
            "abbreviatedOid": "101491b"
          },
          "author": "PedramHD",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-27T19:40:41Z",
          "updatedAt": "2025-03-27T19:40:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 14,
      "id": "PR_kwDOOKn4ys6RfYTK",
      "title": "Clarify that none of the current countermeasures require AS changes",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/pull/14",
      "state": "MERGED",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Do we need to explicitly explain why an AS change (e.g., to only accept its issuer identifier) does not help at all in preventing the attacks?\r\n\r\nFixes #12",
      "createdAt": "2025-04-05T06:14:18Z",
      "updatedAt": "2025-04-28T13:55:02Z",
      "baseRepository": "SECtim/draft-wuertele-oauth-security-topics-update",
      "baseRefName": "main",
      "baseRefOid": "f9ff75120236075925338e7a366b168b5d4f13cf",
      "headRepository": "SECtim/draft-wuertele-oauth-security-topics-update",
      "headRefName": "fix_12",
      "headRefOid": "9f0f4ddf7bd7f3659b965bc47fa2ceb670cd9ffd",
      "closedAt": "2025-04-28T13:55:02Z",
      "mergedAt": "2025-04-28T13:55:02Z",
      "mergedBy": "PedramHD",
      "mergeCommit": {
        "oid": "6938a933310a9677d05bea44fcf77d8d444c9bad"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOOKn4ys6jyseW",
          "commit": {
            "abbreviatedOid": "9f0f4dd"
          },
          "author": "adon-at-work",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-07T20:00:55Z",
          "updatedAt": "2025-04-07T20:01:18Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Based on Section 4.1.3 of RFC7519, the very generic clause of how `aud` can be used, it sounds like you're saying the authorization servers are expected to **readily** accept `aud={issuer}`, `aud={token_endpoint}`, `aud={revoke_endpoint}`, `aud={par_endpoint}` etc that identify themselves. Is this realistic though, when most other specs were suggesting clients to send `aud={token_endpoint}`?\r\n\r\nMy two cents. Think about I'm building a client that wants to support 3 servers. It's always better to define a clear (and standardized) contract between clients and servers. A client then needs to not to maintain a map like serverA can only take `token_endpoint`, while server B&C accept only `issuer` (nowhere this is communicated through openid/oauth metadata??).",
              "createdAt": "2025-04-07T20:00:55Z",
              "updatedAt": "2025-04-07T20:14:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOKn4ys6j3Y6L",
          "commit": {
            "abbreviatedOid": "9f0f4dd"
          },
          "author": "SECtim",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-08T08:55:11Z",
          "updatedAt": "2025-04-08T08:55:11Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "From a (pure) spec perspective, the AS is ready to accept these values due to the very generic language in RFC 7519. For some endpoints like PAR and CIBA, that's also explicitly required by the respective specs (see the discussion in #13). I.e., there are no _normative_ changes to the AS, which is what the current text says.\r\n\r\nThat said (and taking into consideration the engineer perspective): What is your proposal? Should the text explicitly say that even though there as no normative changes, a concrete AS implementation may need to be adapted? Or are you suggesting to make normative changes, i.e., _requiring_ as AS to (only?) accept its issuer identifier and/or the exact endpoint as `aud`, even though that's not strictly necessary to prevent the attack?\r\n\r\n> It's always better to define a clear (and standardized) contract between clients and servers. A client then needs to not to maintain a map like serverA can only take token_endpoint, while server B&C accept only issuer\r\n\r\nThe current text actually does this (albeit not in a normative way) - it basically says: If you as a client use Discovery/AS Metadata with that AS, then use the issuer identifier; otherwise, use the exact endpoint URI (as the sole `aud` value in both cases). The AS can safely accept both (or, for example, require its clients to always use AS Metadata, and hence, the issuer identifier, as is the case, e.g., for FAPI 2.0 SP).\r\n\r\nDo you propose to make this distinction (AS Metadata/Discovery => Issuer Identifier; otherwise => exact endpoint) an explicit normative requirement?\r\nWe tried to avoid that to leave ecosystems the option to, e.g., always use the issuer identifier, even if they don't use AS Metadata/Discovery (in which case the client needs to validate the \"issuer identifier to endpoints\" mapping out of band, but getting AS information out of band, e.g., by configuration, is a common practice anyway; and the language in #15 clearly requires clients to actually validate this mapping).\r\nNote that leaving this option open is also necessary to not create a conflict with the OAuth WG's 7523-bis draft and the current text for an OIDC errata that require clients to use the issuer identifier (regardless of whether the AS Metadata/Discovery mechanism is used).\r\n\r\n>  (nowhere this is communicated through openid/oauth metadata??).\r\n\r\nTrue, it currently isn't and never was - this problem isn't new. Actually, this is another reason for expecting that many of the ASs that rely on clients getting all required metadata via AS Metadata/Discovery will already be pretty liberal in what they accept as `aud`.",
              "createdAt": "2025-04-08T08:55:11Z",
              "updatedAt": "2025-04-08T08:55:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOKn4ys6m21wq",
          "commit": {
            "abbreviatedOid": "9f0f4dd"
          },
          "author": "PedramHD",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-28T13:54:23Z",
          "updatedAt": "2025-04-28T13:54:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 15,
      "id": "PR_kwDOOKn4ys6RffU5",
      "title": "Require clients to validate the issuer identifier",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/pull/15",
      "state": "MERGED",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Also, better describe the difference to the \"issuer\" in RFC 9700.\r\n\r\nFixes #10",
      "createdAt": "2025-04-05T06:37:29Z",
      "updatedAt": "2025-04-28T13:59:02Z",
      "baseRepository": "SECtim/draft-wuertele-oauth-security-topics-update",
      "baseRefName": "main",
      "baseRefOid": "f9ff75120236075925338e7a366b168b5d4f13cf",
      "headRepository": "SECtim/draft-wuertele-oauth-security-topics-update",
      "headRefName": "fix_10",
      "headRefOid": "a20f0032e69b0b5bc0e494a0e583322763bdddc7",
      "closedAt": "2025-04-28T13:59:02Z",
      "mergedAt": "2025-04-28T13:59:02Z",
      "mergedBy": "PedramHD",
      "mergeCommit": {
        "oid": "98ba90c9a9c1e7c957c3f34c67e4a00b49dd976f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOOKn4ys6jywD7",
          "commit": {
            "abbreviatedOid": "ca7cef7"
          },
          "author": "adon-at-work",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-07T20:06:28Z",
          "updatedAt": "2025-04-07T20:06:29Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Clients ~they~ MUST retrieve",
              "createdAt": "2025-04-07T20:06:29Z",
              "updatedAt": "2025-04-07T20:06:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOKn4ys6j241Z",
          "commit": {
            "abbreviatedOid": "ca7cef7"
          },
          "author": "SECtim",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-08T08:09:54Z",
          "updatedAt": "2025-04-08T08:09:55Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Good catch! Thanks!",
              "createdAt": "2025-04-08T08:09:54Z",
              "updatedAt": "2025-04-08T08:09:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOKn4ys6m25ZY",
          "commit": {
            "abbreviatedOid": "a20f003"
          },
          "author": "PedramHD",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-28T13:58:38Z",
          "updatedAt": "2025-04-28T13:58:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 16,
      "id": "PR_kwDOOKn4ys6Rfiei",
      "title": "Explain why clients regularly use the token EP as audience",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/pull/16",
      "state": "MERGED",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #8",
      "createdAt": "2025-04-05T07:04:09Z",
      "updatedAt": "2025-04-28T14:05:33Z",
      "baseRepository": "SECtim/draft-wuertele-oauth-security-topics-update",
      "baseRefName": "main",
      "baseRefOid": "f9ff75120236075925338e7a366b168b5d4f13cf",
      "headRepository": "SECtim/draft-wuertele-oauth-security-topics-update",
      "headRefName": "fix_8",
      "headRefOid": "4e2708494311ef9b35031d9b01359938d24b61bc",
      "closedAt": "2025-04-28T14:05:32Z",
      "mergedAt": "2025-04-28T14:05:32Z",
      "mergedBy": "PedramHD",
      "mergeCommit": {
        "oid": "30f3313b338b3482190f7eb21f2c40bd40180461"
      },
      "comments": [
        {
          "author": "adon-at-work",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks",
          "createdAt": "2025-04-07T20:04:51Z",
          "updatedAt": "2025-04-07T20:04:51Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOOKn4ys6m2_LD",
          "commit": {
            "abbreviatedOid": "4e27084"
          },
          "author": "PedramHD",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-28T14:05:16Z",
          "updatedAt": "2025-04-28T14:05:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 17,
      "id": "PR_kwDOOKn4ys6TE0Hf",
      "title": "First draft of Mix-up Reloaded Work",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/pull/17",
      "state": "MERGED",
      "author": "KevinLuo2000",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Resolves #3.\r\n\r\nPreview: https://kevinluo2000.github.io/TestIETF/draft-wuertele-oauth-security-topics-update.html\r\n\r\nCurrently, I separated the mix-up updates that are open ecosystem-agnostic (Section 2.2) from those that have to do with the open ecosystem/issuer-sharing setting (Section 2.3.1-2.3.3), and added a preliminary draft on the newly-developed RS mix-up idea (Section 2.3.4, now referred to as \u201cClient Configuration Confusion Attack\u201d).\r\n\r\nThe contents are based on:\r\n\r\n- Our original proposed updates to IETF [Dec 2024-Jan 2025]\r\n- Feedback from Aaron, Daniel, Guido, and others at OAuth Security Workshop [Feb 2025]\r\n    - Especially, clearly define what constitutes an integrated \u201capp\u201d, and use an alternative term to avoid the confusion with what an \u201capplication\u201c usually stands for in OAuth\r\n- Follow-up discussions (mainly with @SECtim) in the OAuth Security Workshop\u2019s \\#mix-up-attacks Slack channel [Mar-Apr 2025]\r\nas well as invaluable insights/feedback from one-on-one discussions/group meeting with @adon-at-work @SECtim @PedramHD , and my research group.\r\n\r\nNote that I still have some unresolved comments from @adon-at-work side, regarding the structure and writing style. I will post them as GitHub issues and start resolving them in the upcoming days.",
      "createdAt": "2025-04-18T06:06:35Z",
      "updatedAt": "2025-06-16T07:38:31Z",
      "baseRepository": "SECtim/draft-wuertele-oauth-security-topics-update",
      "baseRefName": "main",
      "baseRefOid": "30f3313b338b3482190f7eb21f2c40bd40180461",
      "headRepository": "KevinLuo2000/draft-wuertele-oauth-security-topics-update",
      "headRefName": "main",
      "headRefOid": "0f28c608607d9a3dab262de4c66af374babef8fd",
      "closedAt": "2025-06-16T07:38:30Z",
      "mergedAt": "2025-06-16T07:38:30Z",
      "mergedBy": "SECtim",
      "mergeCommit": {
        "oid": "85df0ebe81af3f1beb52026ad33099965cf70637"
      },
      "comments": [
        {
          "author": "KevinLuo2000",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for your prompt review! Let me resolve the important comments and I'll then merge the commits.",
          "createdAt": "2025-06-13T09:48:42Z",
          "updatedAt": "2025-06-13T09:48:42Z"
        },
        {
          "author": "SECtim",
          "authorAssociation": "OWNER",
          "body": "Thanks a lot for going through my (many) comments :smiley: ",
          "createdAt": "2025-06-16T07:21:40Z",
          "updatedAt": "2025-06-16T07:21:40Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOOKn4ys6uHtR-",
          "commit": {
            "abbreviatedOid": "163f9e4"
          },
          "author": "SECtim",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Thanks for this extensive PR! I like the writing style and (most of the) structure. \r\nPlease interpret my comments as suggestions (of varying importance) - if there's need for discussion on some (or all) of them, we can just move them to issues and merge this PR nonetheless, so we can get a first individual I-D out soon.\r\n\r\nHence my approval despite the many comments :smile: ",
          "createdAt": "2025-06-12T13:48:33Z",
          "updatedAt": "2025-06-12T14:50:02Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "With all due respect, it does not look to me like Adonis provided substantial text to this draft (but please correct me if I am wrong about this!). Reviewing a draft is commonplace in the IETF, reviewers are then usually listed in the acknowledgments section.",
              "createdAt": "2025-06-12T13:48:33Z",
              "updatedAt": "2025-06-12T14:50:02Z"
            },
            {
              "originalPosition": 71,
              "body": "This gets rendered as `Authors, M. C. P. S.` in the reference section. Can we just supply an `ins` element with the full `Model Context Protocol Specification Authors` again?\r\nI did not really check the MCP spec for different authorship information, but maybe we can instead list an organization or smth. similar here?",
              "createdAt": "2025-06-12T13:51:57Z",
              "updatedAt": "2025-06-12T14:50:03Z"
            },
            {
              "originalPosition": 174,
              "body": "> it is implicitly assumed that each authorization server has only one client configuration at a client\r\n\r\nI know what you mean by that and with the above definition of \"client configuration\", all the information is there to understand this statement - but I think this might confuse readers not already familiar with the topic, because in the traditional setting, a client \"has a configuration\" at an AS, not the other way round. Maybe it is possible to express this in terms of the traditional OAuth model, e.g.,\r\n\r\n> In traditional OAuth deployments, it is implicitly assumed that there is exactly one client configuration for each client-authorization server pair.",
              "createdAt": "2025-06-12T14:01:43Z",
              "updatedAt": "2025-06-12T14:50:03Z"
            },
            {
              "originalPosition": 157,
              "body": "A more tangible example might help readers to get on the right (mental) track, e.g.,\r\n\r\n> ... associated authorization servers at development time (e.g., in integration platforms, where external services register themselves as authorization and resource servers with a platform that acts as a client, see {{research.cuhk}})\r\n\r\n... maybe even more concrete?",
              "createdAt": "2025-06-12T14:05:12Z",
              "updatedAt": "2025-06-12T14:50:03Z"
            },
            {
              "originalPosition": 157,
              "body": "It might be helpful for readers to explicitly say something along the lines of \"in what we refer to as open ecosystems, the registration roles are reversed: ...\" at the beginning of that paragraph.\r\n\r\nThinking about it, I am not sure I agree with defining \"open ecosystems\" as\r\n\r\n> protected resources accessible to a client are configured beyond the discretion of the client or client developers\r\n\r\n... because deciding what is accessible to a client is up to the AS/RS/RO in the traditional OAuth model as well. Or am I missing something here? Is there a good reason to not define \"open ecosystems\" via the \"reversed registration\" characteristic?",
              "createdAt": "2025-06-12T14:15:06Z",
              "updatedAt": "2025-06-12T14:50:03Z"
            },
            {
              "originalPosition": 172,
              "body": "At this point, readers do not yet know what \"issuer sharing\" is, I guess that's the reason for the \"(explained below)\". I suggest putting \"(explained below)\" or \"(see below)\" right after \"issuer-sharing\", so readers don't get hung up on this term.",
              "createdAt": "2025-06-12T14:18:55Z",
              "updatedAt": "2025-06-12T14:50:03Z"
            },
            {
              "originalPosition": 174,
              "body": "> Under this assumption, the issuer serves as a unique identifier for the client.\r\n\r\nI think we should be very explicit about what we mean by \"the issuer\" in this context (because that's exactly where the problem is).\r\n\r\n```suggestion\r\nIn traditional OAuth deployments, it is implicitly assumed that each authorization server has only one client configuration at a client. Under this assumption, the issuer (as defined in {{Section 4.4.2 of !RFC9700}}) serves as a unique identifier for the client. This has led to the common practice of clients tracking \"the authorization server chosen by the user\" during OAuth flows, as well as the adoption of existing mix-up defenses ({{Section 4.4.2 of !RFC9700}}), all of which are based on the issuer concept that uniquely identifies each authorization server.\r\n```",
              "createdAt": "2025-06-12T14:23:13Z",
              "updatedAt": "2025-06-12T14:50:03Z"
            },
            {
              "originalPosition": 174,
              "body": "> all of which are based on the issuer concept that uniquely identifies each authorization server.\r\n\r\nI suggest adding (at the end):\r\n\r\n> all of which are based on the issuer concept that uniquely identifies each authorization server from the client's point of view. However, crucially, the issuer does not uniquely identify a client configuration as defined above.",
              "createdAt": "2025-06-12T14:25:20Z",
              "updatedAt": "2025-06-12T14:50:03Z"
            },
            {
              "originalPosition": 187,
              "body": "This section is labeled \"Attack Description\", but I don't think anyone not already familiar with the topic will have a good understanding of the attack after reading this section.\r\nIt feels like the stage is set by explaining that open ecosystems extend the RFC 9700 scenario, but the remaining paragraphs don't really explain the actual attack.",
              "createdAt": "2025-06-12T14:33:18Z",
              "updatedAt": "2025-06-12T14:50:03Z"
            },
            {
              "originalPosition": 212,
              "body": "I think the current state makes sense.",
              "createdAt": "2025-06-12T14:34:35Z",
              "updatedAt": "2025-06-12T14:50:03Z"
            },
            {
              "originalPosition": 254,
              "body": "```suggestion\r\n4. The client redeems the code issued by H-AS at H-AS's token endpoint. To authenticate with H-AS, the client creates a client assertion signed by itself. Recall that both A-Config and H-Config registered the client with H-AS under the same client ID, and that the client uses the same key pair for authentication at H-AS. Hence, this client assertion, if required, would be a valid authentication credential for the client at H-AS. Generating client assertions in this step is of course only relevant for confidential clients.\r\n```\r\n\r\nPublic clients cannot authenticate (by definition, see Sec. 2 of RFC 6749).",
              "createdAt": "2025-06-12T14:41:23Z",
              "updatedAt": "2025-06-12T14:50:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOKn4ys6uJHxd",
          "commit": {
            "abbreviatedOid": "163f9e4"
          },
          "author": "PedramHD",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-12T15:11:09Z",
          "updatedAt": "2025-06-12T15:11:09Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOOKn4ys6uS8oi",
          "commit": {
            "abbreviatedOid": "163f9e4"
          },
          "author": "KevinLuo2000",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-13T10:12:10Z",
          "updatedAt": "2025-06-13T10:12:10Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Thanks for the question!\r\nWhile the commits were pushed by me, I worked closely with Adonis when producing the texts (we work as a team and communicate via email and weekly meetings), so his contribution went beyond a reviewer role. \r\nAfter we publish the first version of I-D, he may also directly edit the spec through PRs, which I'm sure will make our sections more engineer-friendly.",
              "createdAt": "2025-06-13T10:12:10Z",
              "updatedAt": "2025-06-13T10:12:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOKn4ys6uTd4C",
          "commit": {
            "abbreviatedOid": "163f9e4"
          },
          "author": "KevinLuo2000",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-13T11:01:19Z",
          "updatedAt": "2025-06-13T11:01:19Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "Good catch!\r\n\r\n\"Model Context Protocol is an open source project run by [Anthropic, PBC.](https://anthropic.com/) and open to contributions from the entire community.\"\r\n\r\nMCP an open protocol first introduced by Anthropic but contributed by the broader community. I'll use Anthropic as author in the reference for now and update it if needed later.",
              "createdAt": "2025-06-13T11:01:19Z",
              "updatedAt": "2025-06-13T11:01:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOKn4ys6uT4r7",
          "commit": {
            "abbreviatedOid": "163f9e4"
          },
          "author": "KevinLuo2000",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-13T11:22:37Z",
          "updatedAt": "2025-06-13T11:22:37Z",
          "comments": [
            {
              "originalPosition": 212,
              "body": "Sure, marked as resolved.",
              "createdAt": "2025-06-13T11:22:37Z",
              "updatedAt": "2025-06-13T11:22:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOKn4ys6uU3pZ",
          "commit": {
            "abbreviatedOid": "163f9e4"
          },
          "author": "KevinLuo2000",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-13T12:53:27Z",
          "updatedAt": "2025-06-13T12:53:27Z",
          "comments": [
            {
              "originalPosition": 174,
              "body": "> However, crucially, the issuer does not uniquely identify a client configuration as defined above.\r\n\r\nI'm not sure if we should add it under this \"traditional OAuth deployments\" paragraph. \r\n\r\nIn traditional OAuth deployments, there is exactly one client configuration for each client-authorization server pair. So if we are only talking about uniqueness/unique identifier, from the client's point of view, issuer==client configuration==authorization server.",
              "createdAt": "2025-06-13T12:53:27Z",
              "updatedAt": "2025-06-15T12:03:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOKn4ys6uWC3m",
          "commit": {
            "abbreviatedOid": "163f9e4"
          },
          "author": "KevinLuo2000",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-13T14:21:06Z",
          "updatedAt": "2025-06-13T14:21:06Z",
          "comments": [
            {
              "originalPosition": 254,
              "body": "When I wrote this paragraph, I was referring to section 2.3 of RFC6749, where there is a MAY for public clients:\r\n> The authorization server MAY establish a client authentication method with public clients.  However, the authorization server MUST NOT rely on public client authentication for the purpose of identifying the client.\r\n\r\nThat said, I've updated as what you suggested.",
              "createdAt": "2025-06-13T14:21:06Z",
              "updatedAt": "2025-06-13T14:21:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOKn4ys6uZf7L",
          "commit": {
            "abbreviatedOid": "163f9e4"
          },
          "author": "KevinLuo2000",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-13T18:29:44Z",
          "updatedAt": "2025-06-13T18:29:44Z",
          "comments": [
            {
              "originalPosition": 187,
              "body": "Agree. The \"Attack Description\" did not really explain how an attack can be mounted.\r\n\r\nI've now included the full description of a mix-up attack variant in such open ecosystem setting. ",
              "createdAt": "2025-06-13T18:29:44Z",
              "updatedAt": "2025-06-13T18:29:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOKn4ys6uZhTq",
          "commit": {
            "abbreviatedOid": "163f9e4"
          },
          "author": "KevinLuo2000",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-13T18:30:47Z",
          "updatedAt": "2025-06-13T18:30:47Z",
          "comments": [
            {
              "originalPosition": 172,
              "body": "Nice suggestion.",
              "createdAt": "2025-06-13T18:30:47Z",
              "updatedAt": "2025-06-13T18:30:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOKn4ys6uaWp-",
          "commit": {
            "abbreviatedOid": "163f9e4"
          },
          "author": "KevinLuo2000",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-13T19:37:57Z",
          "updatedAt": "2025-06-13T19:37:57Z",
          "comments": [
            {
              "originalPosition": 157,
              "body": "This is a good point and I do have some special considerations in the wording.\r\nWill come back to this later.",
              "createdAt": "2025-06-13T19:37:57Z",
              "updatedAt": "2025-06-13T19:37:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOKn4ys6urlbW",
          "commit": {
            "abbreviatedOid": "163f9e4"
          },
          "author": "KevinLuo2000",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-16T05:18:32Z",
          "updatedAt": "2025-06-16T05:18:33Z",
          "comments": [
            {
              "originalPosition": 157,
              "body": "> It might be helpful for readers to explicitly say something along the lines of \"in what we refer to as open ecosystems, the registration roles are reversed: ...\" at the beginning of that paragraph.\r\n...\r\nIs there a good reason to not define \"open ecosystems\" via the \"reversed registration\" characteristic?\r\n\r\nThanks for the question! I'd say the intended generalizability of the spec may influence how we adjust the language.\r\n\r\nI did not define \"open ecosystems\" using the \"reversed registration\" characteristic because:\r\n\r\n* Two open ecosystem patterns:\r\n  - For Integration Platforms (the focus of our research paper), the \"reversed registration\" pattern makes perfect sense. The AS/RS, as external developers of the integration platform, proactively registers at the client, which is a reverse direction compared with ordinary OAuth deployments.\r\n  - However, in the spec, I also want to be less restrictive, and incorporate another possible open ecosystem pattern, that is gaining popularity in the AI Agent space (e.g., within the MCP protocol). In this case, the \"openness\" in the ecosystem stems not from external developers, but from end-users, who can enter ANY AS/RS's urls, and make the client interact with them.\r\n  - AFAIK, the \"reversed registration\" characteristic does **not** apply to this second case, since the AS/RS is still passively waiting for a non-reversed registration. \r\n* Nuance between \"registration\" and \"integration\":\r\n  - I also want to avoid overloading the term \"registration\", which in OAuth typically refers to client registration, i.e., the client already knows which AS it wants to contact, and goes register with the AS to obtain a client id and credential. What we're describing here is how the client decides which AS and RS to interact with, which I believe is better captured by the term \"integration\" rather than \"registration\".\r\n* On the term \"reversed\":\r\n  - I'm also unsure whether the term \"reversed\" might be a bit overloaded. If all AS/RS/Client registration information are manually provided (e.g., filled in as a form at the client's developer portal as in Integration Platforms), we could for sure confidently use the term \"reversed\". But if AS Metadata/PRM/DCR is used, then the AS Metadata/PRM/Client Registration Request shall be sent from the client to the AS/RS, which does not reflect the \"reversed\" pattern.\r\n\r\n\r\n----\r\nTo further explain my stance on the definition of open ecosystem, I'd like to reference the following RFCs:\r\n\r\nRFC8414 Authorization Server Metadata [Section 1](https://datatracker.ietf.org/doc/html/rfc8414#section-1):\r\n> The means by which the client chooses an authorization server is out\r\n   of scope.  In some cases, its issuer identifier may be **manually\r\n   configured** into the client.  In other cases, it may be **dynamically\r\n   discovered**, for instance, through the use of WebFinger [[RFC7033](https://www.rfc-editor.org/rfc/rfc7033)], as\r\n   described in [Section 2](https://www.rfc-editor.org/rfc/rfc8414#section-2) of \"OpenID Connect Discovery 1.0\"\r\n   [[OpenID.Discovery](https://www.rfc-editor.org/rfc/rfc8414#ref-OpenID.Discovery)].\r\n\r\n\r\nRFC9728 Protected Resource Metadata [Section 1](https://datatracker.ietf.org/doc/html/rfc9728#section-1-2):\r\n> The means by which the client obtains the location of the protected\r\n   resource is out of scope for this document.  In some cases, the\r\n   location may be **manually configured** into the client; for example, an\r\n   email client could provide an interface for a user to enter the URL\r\n   of their JSON Meta Application Protocol (JMAP) server [RFC8620].  In\r\n   other cases, it may be **dynamically discovered**; for example, a user\r\n   could enter their email address into an email client, the client\r\n   could perform WebFinger discovery [RFC7033] (in a manner related to\r\n   the description in Section 2 of [OpenID.Discovery]) to find the\r\n   resource server, and the client could then fetch the resource server\r\n   metadata to find the authorization server to use to obtain\r\n   authorization to access the user's email.\r\n\r\n\r\nOverall, rather than separating based on whether the AS/RS is \"manually configured\" or \"dynamically discovered\" (as above), I'd propose a different separation, based on _who_ integrates the AS and RS:\r\n- If it's the client or client developer, then it's a more trusted environment (unless you don't trust the client at all, which is a different story), because the client can solely decide which AS/RS to integrate based on its needs. This is what I referred to as the \"traditional OAuth deployments\".\r\n- If the integration is initiated by external developers or end-users, then it's a less trusted environment, because the client cannot, or at least is not the only party involved in making the integration decision. This is what I try to define as the \"open ecosystems\" pattern.\r\n\r\n----\r\n> I am not sure I agree with defining \"open ecosystems\" as below, because deciding what is accessible to a client is up to the **AS/RS/RO** in the traditional OAuth model as well.\r\n> > protected resources accessible to a client are configured beyond the discretion of the client or client developers\r\n\r\n\r\nI agree this is a bit confusing. Though I haven't found a satisfactory alternative yet.\r\n\r\n* If an **RO** (i.e., end-user) can decide what is accessible to the client, I guess it's more like the two examples in the RFC9728 Section 1 paragraph above. I think this case can fall under our definition of open ecosystems (similar to the MCP case).\r\n* If an **AS/RS** can decide what is accessible to a client, I guess we should further distinguish the nuance between \"expose\" and \"configure\":\r\n  - If the AS/RS's role is to decide whether to _expose_ a certain resource to a particular client (so that the resource can/cannot be accessible to the client), I would say this is orthogonal to what we try to define here. But we may need to clarify the language to avoid confusion.\r\n  - If the AS/RS's role is to decide whether to _configure_ itself at a particular client, I'd say this falls under our definition of open ecosystems (the Integration Platform case).\r\n\r\n----\r\n\r\nI've also touched up the language around \"client configurations\", so that the concept is not limited to open ecosystem, but also applicable to the traditional OAuth model. \r\n\r\nFeel free to let me know if the above explanations are helpful. We can work on the changes/discuss further in issues.",
              "createdAt": "2025-06-16T05:18:33Z",
              "updatedAt": "2025-06-16T06:56:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOKn4ys6usWMl",
          "commit": {
            "abbreviatedOid": "163f9e4"
          },
          "author": "SECtim",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-16T07:04:02Z",
          "updatedAt": "2025-06-16T07:04:02Z",
          "comments": [
            {
              "originalPosition": 174,
              "body": "I see your point :thinking: My intention was to avoid confusion for readers and very explicitly point out that while the issuer does identify an AS, it does not (necessarily) uniquely identify a client configuration (in open ecosystems, which is the section this text is placed in).\r\n\r\nMaybe we can instead point that out the following paragraph, something like:\r\n\r\n> In open ecosystems, however, the new integration pattern does not, and fundamentally cannot, restrict the use of the same authorization server across multiple client configurations. For instance, clients may legitimately integrate various functionalities that access different resources or process the same resources differently, while relying on the same authorization server (i.e., having shared issuers **- therefore, the issuer no longer uniquely identifies a client configuration**).\r\n",
              "createdAt": "2025-06-16T07:04:02Z",
              "updatedAt": "2025-06-16T07:04:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOKn4ys6usbhE",
          "commit": {
            "abbreviatedOid": "163f9e4"
          },
          "author": "SECtim",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-16T07:12:19Z",
          "updatedAt": "2025-06-16T07:12:19Z",
          "comments": [
            {
              "originalPosition": 157,
              "body": "Resolving this, moved to #26 ",
              "createdAt": "2025-06-16T07:12:19Z",
              "updatedAt": "2025-06-16T07:12:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOKn4ys6usgzw",
          "commit": {
            "abbreviatedOid": "163f9e4"
          },
          "author": "SECtim",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-16T07:20:40Z",
          "updatedAt": "2025-06-16T07:20:40Z",
          "comments": [
            {
              "originalPosition": 174,
              "body": "Moved to #27, resolving this.",
              "createdAt": "2025-06-16T07:20:40Z",
              "updatedAt": "2025-06-16T07:20:40Z"
            }
          ]
        }
      ]
    },
    {
      "number": 28,
      "id": "PR_kwDOOKn4ys6ar2lS",
      "title": "Explicitly point out issuer does not unique identify client config in open ecosystems",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/pull/28",
      "state": "MERGED",
      "author": "KevinLuo2000",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Resolves #27 .",
      "createdAt": "2025-06-16T10:14:45Z",
      "updatedAt": "2025-06-16T11:03:07Z",
      "baseRepository": "SECtim/draft-wuertele-oauth-security-topics-update",
      "baseRefName": "main",
      "baseRefOid": "85df0ebe81af3f1beb52026ad33099965cf70637",
      "headRepository": "KevinLuo2000/draft-wuertele-oauth-security-topics-update",
      "headRefName": "main",
      "headRefOid": "094334b0af91a799ac50644635bbbb39004687b6",
      "closedAt": "2025-06-16T11:03:07Z",
      "mergedAt": "2025-06-16T11:03:07Z",
      "mergedBy": "SECtim",
      "mergeCommit": {
        "oid": "01ead8e40eb0d5ccc3294974991b27796eaf793c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOOKn4ys6uvVkD",
          "commit": {
            "abbreviatedOid": "094334b"
          },
          "author": "SECtim",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2025-06-16T11:02:58Z",
          "updatedAt": "2025-06-16T11:02:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 29,
      "id": "PR_kwDOOKn4ys6auMzv",
      "title": "Minor touch-up for better readability",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/pull/29",
      "state": "MERGED",
      "author": "KevinLuo2000",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Updated (temporary) title and introductory paragraphs.\r\nCleaned up acknowledgement list.\r\nAdded document history.",
      "createdAt": "2025-06-16T13:42:14Z",
      "updatedAt": "2025-06-16T22:13:32Z",
      "baseRepository": "SECtim/draft-wuertele-oauth-security-topics-update",
      "baseRefName": "main",
      "baseRefOid": "01ead8e40eb0d5ccc3294974991b27796eaf793c",
      "headRepository": "KevinLuo2000/draft-wuertele-oauth-security-topics-update",
      "headRefName": "minor-touch-up",
      "headRefOid": "2eb85829d43e2678b5e8ab4790a096130746824f",
      "closedAt": "2025-06-16T16:42:40Z",
      "mergedAt": "2025-06-16T16:42:40Z",
      "mergedBy": "SECtim",
      "mergeCommit": {
        "oid": "a9646f7cec41df6f651d5a9c0eb102e493aad1a9"
      },
      "comments": [
        {
          "author": "KevinLuo2000",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the review and comments!",
          "createdAt": "2025-06-16T22:13:32Z",
          "updatedAt": "2025-06-16T22:13:32Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOOKn4ys6uxgE7",
          "commit": {
            "abbreviatedOid": "80a7d55"
          },
          "author": "KevinLuo2000",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-16T13:45:12Z",
          "updatedAt": "2025-06-16T13:52:41Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I admit this looks a bit awkward because as for now, we only have one technical section, which is Section 2.\r\nIn the future, we may have additional sections depending on our needs, such as an updated \"Best Practices\" and \"The Updated OAuth 2.0 Attacker Model\" section (as Section 2 & 3 of RFC9700).",
              "createdAt": "2025-06-16T13:45:12Z",
              "updatedAt": "2025-06-16T13:53:19Z"
            },
            {
              "originalPosition": 25,
              "body": "I am thinking that since we only have 2 or 3 attacks for now, a tightened description that could encompass some of the shared characteristics of the attacks (like this) may help make a tangible first impression.",
              "createdAt": "2025-06-16T13:49:56Z",
              "updatedAt": "2025-06-16T13:52:41Z"
            },
            {
              "originalPosition": 52,
              "body": "This comment format does not look nice when rendered on datatracker, see https://datatracker.ietf.org/doc/html/draft-wuertele-oauth-security-topics-update-00#name-acknowledgments.\r\n\r\nMaybe we should change some comments to plaintext inline, and track some other with issues instead?",
              "createdAt": "2025-06-16T13:51:54Z",
              "updatedAt": "2025-06-16T13:55:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOKn4ys6uxsRU",
          "commit": {
            "abbreviatedOid": "80a7d55"
          },
          "author": "KevinLuo2000",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-16T13:58:49Z",
          "updatedAt": "2025-06-16T13:58:49Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Thinking about this, maybe we should define what is the attacker model of our attacks in the respective attack section.\r\nReference:\r\nAttacker (A1) - (A5) in https://datatracker.ietf.org/doc/html/rfc9700#section-3.",
              "createdAt": "2025-06-16T13:58:49Z",
              "updatedAt": "2025-06-16T14:00:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOKn4ys6uzxwv",
          "commit": {
            "abbreviatedOid": "2eb8582"
          },
          "author": "SECtim",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Looks good to me - thanks!",
          "createdAt": "2025-06-16T16:38:06Z",
          "updatedAt": "2025-06-16T16:41:37Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Good idea referencing the attacker model in RFC 9700! I'll put that in an issue",
              "createdAt": "2025-06-16T16:38:06Z",
              "updatedAt": "2025-06-16T16:41:37Z"
            },
            {
              "originalPosition": 52,
              "body": "I am open to suggestions - as long as we keep it consistent and comments are clearly marked as such (or is there any specific guidance on how to add comments in the IETF process docs?).\r\n\r\nThat said, for the initial round of feedback, I don't think it's necessary to change the comment format.",
              "createdAt": "2025-06-16T16:41:14Z",
              "updatedAt": "2025-06-16T16:41:37Z"
            }
          ]
        }
      ]
    }
  ]
}