{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-05-06T01:47:52.003155+00:00",
  "repo": "SECtim/draft-wuertele-oauth-security-topics-update",
  "labels": [
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "editorial",
      "description": "Typos, formatting, and the like.",
      "color": "17E24A"
    },
    {
      "name": "Needs WG input",
      "description": "Issue needs input from OAuth WG",
      "color": "2D16D4"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOOKn4ys6utJzJ",
      "title": "Decide on a title",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/1",
      "state": "OPEN",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "Needs WG input"
      ],
      "body": "So far, I've put \"OAuth 2.0 Security Best Current Practice\" as the title, but it might make sense to use a different title to at least indicate that this is an extension of an existing document of that name.",
      "createdAt": "2025-03-19T09:29:09Z",
      "updatedAt": "2025-04-05T05:36:43Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 2,
      "id": "I_kwDOOKn4ys6utShA",
      "title": "Description for Audience Injection Attacks",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/2",
      "state": "CLOSED",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [
        "SECtim",
        "PedramHD"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2025-03-19T09:39:58Z",
      "updatedAt": "2025-03-24T16:07:13Z",
      "closedAt": "2025-03-24T16:07:12Z",
      "comments": []
    },
    {
      "number": 3,
      "id": "I_kwDOOKn4ys6utTBW",
      "title": "Description for attacks from mix-up reloaded work",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/3",
      "state": "OPEN",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Exact title and structure to be discussed.",
      "createdAt": "2025-03-19T09:40:32Z",
      "updatedAt": "2025-03-19T09:40:32Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 4,
      "id": "I_kwDOOKn4ys6vXR8L",
      "title": "What RFCs should this document update?",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/4",
      "state": "OPEN",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [
        "SECtim"
      ],
      "labels": [
        "Needs WG input"
      ],
      "body": "\"Update\" in the RFC \"updates\" list sense.\n\nWe certainly have 6749, 9700, and 6750 (due to the \"Mix-Up Reloaded\" issuer sharing cases, where a client ends up sending a bearer token to the wrong RS, thereby leaking it).\n\nProbably also 7521, 7522, and 7523 (or, at the very least, 7523).\n\nAnything else?",
      "createdAt": "2025-03-24T06:13:20Z",
      "updatedAt": "2025-04-05T05:36:24Z",
      "closedAt": null,
      "comments": [
        {
          "author": "SECtim",
          "authorAssociation": "OWNER",
          "body": "Probably also PAR",
          "createdAt": "2025-04-04T06:18:40Z",
          "updatedAt": "2025-04-04T06:18:40Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOOKn4ys6xHAmc",
      "title": "In 2.1, clarify why the token EP is used as aud",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/8",
      "state": "CLOSED",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [
        "SECtim",
        "PedramHD"
      ],
      "labels": [],
      "body": "Based on feedback by @adon-at-work to help readers",
      "createdAt": "2025-04-04T06:32:42Z",
      "updatedAt": "2025-04-28T14:05:34Z",
      "closedAt": "2025-04-28T14:05:33Z",
      "comments": []
    },
    {
      "number": 9,
      "id": "I_kwDOOKn4ys6xQcyD",
      "title": "Make the description of audience injection attacks more self-contained",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/9",
      "state": "OPEN",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [
        "SECtim",
        "PedramHD"
      ],
      "labels": [],
      "body": "(This is part of the feedback by @adon-at-work)\nAs a reader, it would be more readable if it's more self-contained, an engineer is unlikely to go read a full academic paper. (A number of places is referring to paper for details, which is for now a TODO deadlink, and that gave me a hard time. I\u2019m expecting the WG or those first time reader who aren't familiar with the work may have the same impression).",
      "createdAt": "2025-04-05T05:21:49Z",
      "updatedAt": "2025-04-05T05:21:49Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 10,
      "id": "I_kwDOOKn4ys6xQc7x",
      "title": "Clarify the description of the AS issuer identifier defense",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/10",
      "state": "CLOSED",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [
        "SECtim",
        "PedramHD"
      ],
      "labels": [],
      "body": "(This is part of the feedback by @adon-at-work)\n- 2.1.2.1 Reminder about validating issuer field from metadata file, as per [rfc8414#section-3.3](https://datatracker.ietf.org/doc/html/rfc8414#section-3.3). Reminder for not to extract issuer from the token_endpoint string (engineer may be tempted to do so given their current implementation).\n- 2.1.2.1 \u201c\u201dNote that \"issuer identifier\" here does not refer to the term \"issuer\" as defined in {{Section 4.4 of RFC9700}}, but to the issuer identifier as used in {{!RFC8414}} and {{OpenID.Discovery}}.\u201d\u201d What\u2019s the difference?",
      "createdAt": "2025-04-05T05:23:23Z",
      "updatedAt": "2025-04-28T13:59:03Z",
      "closedAt": "2025-04-28T13:59:03Z",
      "comments": []
    },
    {
      "number": 11,
      "id": "I_kwDOOKn4ys6xQdN-",
      "title": "Discuss \"single value audience\" requirements",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/11",
      "state": "OPEN",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [
        "SECtim",
        "PedramHD"
      ],
      "labels": [],
      "body": "(This is part of the feedback by @adon-at-work)\n2.1.2.2 aud=single target endpoint\n- single audience requirement. multiple audiences I think isn't necessarily a bad thing, as long as they are all belonging to the same issuer. ex. [[h-as.com/token](http://h-as.com/token), [h-as.com/revoke](http://h-as.com/revoke)]\n- What's the expectation if I need a cla for token negotiation and then later for revocation. I kinda think it could be a transactional process, I got a token, finish my task, and do clean up. I think it makes sense to reuse the same cla for both. But if its single aud, then i gotta create cla twice, one per endpoint. This can discourage people to cleanup/call revoke given the performance penalty (jti was introduced there for performance/replay reason).\n- let's say we want to allow multiple aud from the same issuer. or more generally, as is today, when people put multiple aud, what's one-time use of `jti`mean? is that one-time use per aud, or across all audiences. should we clarify?",
      "createdAt": "2025-04-05T05:26:13Z",
      "updatedAt": "2025-04-07T22:34:23Z",
      "closedAt": null,
      "comments": [
        {
          "author": "SECtim",
          "authorAssociation": "OWNER",
          "body": "> multiple audiences I think isn't necessarily a bad thing, as long as they are all belonging to the same issuer\n\nThat would require normative changes to the AS; i.e., the AS then MUST verify that it can identify with _all_ elements in the `aud` array before accepting a client assertion (or, maybe better: all elements must be endpoints of the AS). Not necessarily a reason to not include this proposal, but something to be aware of.\n\n> But if its single aud, then i gotta create cla twice, one per endpoint.\n\nOnly when using the \"exact endpoint\" audience defense, i.e., when no issuer identifier is available.\n\n> This can discourage people to cleanup/call revoke given the performance penalty (jti was introduced there for performance/replay reason).\n\nI wouldn't say that `jti` was introduced to enable replay - actually, quite the opposite: To (at least optionally) prevent replay. For example, the default for [OpenID Connect authentication JWTs](https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication) is \"These tokens MUST only be used once\". In the IETF world, the usual formulation is something like \"MAY use `jti` to ensure that JWTs are not replayed\", e.g., in [RFC7519](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.7), [RFC7521](https://datatracker.ietf.org/doc/html/rfc7521#section-5.1), [RFC7522](https://datatracker.ietf.org/doc/html/rfc7522#section-3), [RFC7523](https://datatracker.ietf.org/doc/html/rfc7523#section-3), and [RFC9449](https://datatracker.ietf.org/doc/html/rfc9449#name-dpop-proof-jwt-syntax).\n\n> let's say we want to allow multiple aud from the same issuer. or more generally, as is today, when people put multiple aud, what's one-time use of jti mean? is that one-time use per aud, or across all audiences. should we clarify?\n\nThat's a can of worms this document certainly should not open, because it has nothing to do with audience injection attacks or their mitigation.\nThat said, in my opinion, the original formulations around `jti` and JWT replay/reuse are somewhat unfortunate, because they end up saying \"do whatever you want\" (with the exception of OIDC, but that also leaves the door open to \"unless conditions for reuse were negotiated between the parties\"), instead of giving clear options with their respective pros and cons.\n\n---\n\nSo, to summarize what I think:\n- This document should definitely avoid talking about `jti` and JWT replay/reuse.\n- I am in principle open to discuss the possibility of allowing `aud` arrays, but at least for RFCs 7521, 7522, 7523, and 9126, as well as the OIDF specs OIDC, CIBA, FAPI 1.0, and FAPI 2.0, corresponding updates/drafts thereof do require single-valued audiences; so talking about multi-valued `aud`s here might confuse people.",
          "createdAt": "2025-04-05T08:18:13Z",
          "updatedAt": "2025-04-05T08:18:13Z"
        },
        {
          "author": "adon-at-work",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">  use jti to ensure that JWTs are not replayed\n\nSure. I should word it more carefully. I meant \"jti was introduced there for (trading off between) performance/replay reason\". Performance-critical applications may not want to use `jti`, where security-critical applications use `jti` to prevent replay.\n\nThere were (at least) two specs regarding `jti`\n- https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.7 says `jti` is optional, whereas\n- https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication says `jti` is required \n\nI missed the 2nd spec initially, and thought that most people aren't using `jti` since it's optional (given that replay is, to certain degree, mitigated by `exp` already). So I raised the concerns. \n\nSince `jti` is already a required thing in the context of using jwt as client authentication, then I assume people is likely re-generating a new cla fresh anyway whenever it hits an endpoint. So, I agree we should not bring up `jti`.",
          "createdAt": "2025-04-07T22:32:21Z",
          "updatedAt": "2025-04-07T22:34:22Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "I_kwDOOKn4ys6xQeXp",
      "title": "Clarify that proposed fixes do not require AS changes",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/12",
      "state": "CLOSED",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [
        "SECtim",
        "PedramHD"
      ],
      "labels": [],
      "body": "@adon-at-work's initial feedback includes:\n\n> Draft does NOT mention the need for AS server change. But the openid letter clearly spells it out.\n> - Should AS change its enforcement first (ex. accepting token endpoint today but some clients are presenting aud=issuer)? Or should clients go first? It\u2019s practically impossible to coordinate so many parties to agree on a change, even more unlikely to happen at the same time. Then people will naturally ask for backward compatibility.\n> - Think about the owner of the malicious AS, he will likely have no incentive to update\u2026 but will come up with all kinds of excuses like I can\u2019t update because I have no engineering resources\u2026 Will client still need to send token_endpoint to those not updating yet?\n\n=> Draft should state and explain why the \"aud = issuer identifier\" and \"aud = exact endpoint\" defenses do not require any AS changes.",
      "createdAt": "2025-04-05T05:30:03Z",
      "updatedAt": "2025-04-28T13:55:04Z",
      "closedAt": "2025-04-28T13:55:03Z",
      "comments": []
    },
    {
      "number": 13,
      "id": "I_kwDOOKn4ys6xQfO1",
      "title": "Discuss proposed alternative defense",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/13",
      "state": "OPEN",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [
        "SECtim",
        "PedramHD"
      ],
      "labels": [],
      "body": "(This is part of the feedback by @adon-at-work)\n\n> Easiest and most pragmatic solution that works overnight, that requires only client changes. Client ensures that there\u2019re no overlaps of client_id and token_endpoint pairs for all its ASes (be it existing ones or those by DCR in the future). Unlikely there\u2019s a legit use case where the pair would be the same across two different issuers. Should there be an existing collision, as a remedy, the app can re-register to get a new client_id over DCR from one of the issuers (the legit one is unlikely to reuse client_id) to make things unique.\n\nThink about whether this works and what the client has to watch out for. If viable as a defense, consider adding it.",
      "createdAt": "2025-04-05T05:33:18Z",
      "updatedAt": "2025-04-10T22:58:19Z",
      "closedAt": null,
      "comments": [
        {
          "author": "SECtim",
          "authorAssociation": "OWNER",
          "body": "Also consider ecosystems that always use the same client_id across ASs (e.g., OpenID Federation).",
          "createdAt": "2025-04-05T05:34:20Z",
          "updatedAt": "2025-04-05T05:34:20Z"
        },
        {
          "author": "SECtim",
          "authorAssociation": "OWNER",
          "body": "> requires only client changes\n\nThat is also true for the \"aud = issuer identifier\" and \"aud = exact endpoint\" defenses (see #12).\n\n> Client ensures that there\u2019re no overlaps of client_id and token_endpoint pairs for all its ASes\n\nI actually think that's not sufficient to prevent audience injection attacks, at least not in general. Consider a client that always includes the token and revocation endpoints in its client assertions (which is perfectly fine w.r.t. the relevant standards). In that case, the attacker AS can publish the following metadata (excerpt):\n```\ntoken_endpoint: att.com/token,\nrevocation_endpoint: hon.com/token\n```\nThe client's token request (to what the client thinks is the attacker AS) goes to `att.com/token` (i.e., to the attacker) and includes a client assertion with `aud: [\"att.com/token\", \"hon.com/token\"]`. That `aud` value is also valid for requests to `hon.com/token` (and maybe other endpoints of `hon.com` as well, see #8). Hence, this is an instance of an audience injection attack.\n\nWithout AS changes, most combinations of endpoints with client authentication can be (ab)used in one way or the other by an attacker to obtain a client assertion that's valid somewhere else _unless_ the client chooses an `aud` value that's either the issuer identifier or the exact target endpoint. Hence, I'd be very careful in trying to come up with some \"clever\" way for the client to ensure its AS registrations are \"not attackable\" (and, what's more: Any such requirement on the client would be in conflict with the current and widely implemented logic of \"client ID and AS endpoints are provided by the AS and (mostly) opaque values to the client\" with only very minimal restrictions, such as mandatory HTTPS for the token endpoint).\n\nAlso note that just doing another round of DCR - even if feasible, think of stuff like initial access tokens that are typically one-time use - is not at all guaranteed to result in a different client ID. In some cases, having the same client ID for all registrations of a given client (even across ASs) is mandatory, e.g., in OpenID Federation.\n\nI.e., I think this mechanism might introduce problems in practice and, more importantly, doesn't reliably work as a defense.",
          "createdAt": "2025-04-05T08:42:41Z",
          "updatedAt": "2025-04-05T08:42:41Z"
        },
        {
          "author": "adon-at-work",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with everything you said. \n\nBut as I emphasized, the alternative defense is a **quick-and-dirty** fix (and surely it comes with all those \"cleverness\" concerns here and there as you tried to enumerate...). \n\nThe fundamental difference between our believes may be that I assume a change to `aud=token_EP` will introduce backward compatibility issues, since most (or at least some) ASes accept `aud=token_EP` **only**, as influenced and suggested by many of those specs. But apparently, you seem to expect *all* ASes to readily take any values that identify themselves (could be issuer, token_EP, par_EP, etc, and so no AS change is needed). \n\nIf the assumption is right, there will be compatibility issue. So in this imperfect world, what can a client do to secure itself while still keeping the lights on when these \"standard-non-compliant\" servers will only accept \"aud=token_EP\"?\n\n> Without AS changes, most combinations of endpoints with client authentication can be (ab)used in one way or the other by an attacker to obtain a client assertion that's valid somewhere else unless the client chooses an aud value that's either the issuer identifier or the exact target endpoint.\n\nAgree. Multiple values in aud is asking for trouble.\n\nI see here you're implicitly expecting client to use a **single** aud value for your solution to be secured too. If a client uses the same client_id across all ASes and include all issuers in its `aud=[issuer1, issuer2]`, then it can be screwed too. \n\nSimilarly, the alternative fix is meant for a vulnerable client that uses a **single** `aud = token_EP`. If we want to generalize, it could be said as \"there\u2019re no overlaps of client_id and token_endpoint (or whatever values client use in the aud) pairs for all its ASes\". But of course, this discussion is meaningful only if you're convinced about the backward compatibility issue.",
          "createdAt": "2025-04-07T21:22:43Z",
          "updatedAt": "2025-04-07T22:03:37Z"
        },
        {
          "author": "SECtim",
          "authorAssociation": "OWNER",
          "body": "> fundamental difference between our believes\n\nI agree that we seem to have different believes \ud83d\ude04 \n\n> a change to aud=token_EP will introduce backward compatibility issues, since most (or at least some) ASes accept aud=token_EP only, as influenced and suggested by many of those specs. But apparently, you seem to expect all ASes to readily take any values that identify themselves (could be issuer, token_EP, par_EP, etc, and so no AS change is needed).\n\nMy take on this is twofold: First, the \"expectation\" that an AS will accept the exact target endpoint and its issuer identifier as `aud` is a normative requirement in all specs (that I am aware of) outside of the \"original culprits (OIDC, RFCs 752x)\" that do say something about the `aud` values an AS has to accept (RFC 9126 and CIBA) contain a sentence like: _\"the authorization server MUST accept its issuer identifier, token endpoint URL, or pushed authorization request endpoint URL as values that identify it as an intended audience.\"_ (quote is from the Pushed AuthZ Request RFC)\n\nSecond, in any case, I think we do agree that the current normative language around what `aud` values an AS is allowed to accept does not conflict with the proposed fixes, i.e., they do not require normative changes to the AS.\n\n> So in this imperfect world, what can a client do to secure itself while still keeping the lights on when these \"standard-non-compliant\" servers will only accept \"aud=token_EP\"?\n\nIf you as a client are willing to continue using an AS that\n1. Requires authentication at more than the token endpoint;\n2. Expects its token endpoint as the sole `aud` value at ALL these endpoints (keep in mind, for at least CIBA and PAR, an AS is _explicitly_ required to accept the respective exact endpoint as `aud`);\n3. Does not care enough about its clients' security to change what `aud` values it accepts; and \n4. Does not offer a way for you as a client to update your registered key material\n   1. Note 1: the current text explicitly mentions the possibility of using different key material for each AS as an alternative defense\n   2. Note 2: it is sufficient if the AS just allows the client to rotate their authentication public key, i.e., the AS does not need to support full-blown Dynamic Client Management or similar (and while not _required_ in any spec that I know of - albeit some specs like RFC 7591, OIDC, and OIDC DCR do explicitly mention key rotation, FAPI 2.0 SP \"recommends\" it - I think we can agree that not allowing key rotation is a red flag in the first place)\n\n... then yes, the currently proposed fixes cannot be applied to all communication with that particular AS.\nThat said, I'd argue that this is such a special case that it does not justify including a defense...\n- That will only work in this very particular special case (assuming that some other things are clarified, e.g., the handling of `mtls_endpoint_aliases`),\n- Relies on the AS continuing to only accept its token endpoint,\n- Should certainly NOT be used when any other defense is available,\n- Relies on the client not doing \"strange, but technically allowed\" things when talking to the attacker AS (like using the attacker AS' PAR endpoint as an `aud` value for requests to other endpoints of the attacker AS; note that it is the attacker who \"defines\" what it wants from the client, so if the client wants to talk to the attacker AS, it has to comply), and\n- Breaks currently allowed setups where multiple perfectly honest, standards-compliant ASs may share a token endpoint (probably not a _common_ case, but allowed nonetheless).\n\n... in a BCP update. Including a \"quick and dirty\" works-in-some-scenarios-but-not-in-others defense has huge potential for confusion - and I'd expect to then see clients implement this less-than-ideal defense, but never re-evaluating whether an actual fix can be deployed at a later time.\n\n> But of course, this discussion is meaningful only if you're convinced about the backward compatibility issue.\n\nAs of right now, I am not really convinced that backward compatibility will be a huge issue (see the enumeration of preconditions above). That said, I still see value in discussing, because I may of course overlook things.\n\n---\n\n> I see here you're implicitly expecting client to use a single aud value for your solution to be secured too.\n\nThat is not an implicit expectation, the current text very much explicitly says \"sole audience value\".\n\n> If a client uses the same client_id across all ASes and include all issuers in its aud=[issuer1, issuer2], then it can be screwed too.\n\nIf a client issues an assertion that is _intended_ (which is what `aud` expresses) to be valid at multiple ASs, then it shouldn't come as a surprise that this assertion _will_ be valid at (those exact!) multiple ASs - hence, I would not consider that an attack.\nThat said, _intending_ an authentication credential for multiple ASs (that the client generally has to assume will be issuing different client_ids) is a very strange choice by the client, albeit technically allowed (but will be forbidden by the proposed fixes, not only in this document, but also the proposed updates to RFCs 752x, OIDC, CIBA, ..., which I think is a good thing).\n\n> the alternative fix is meant for a vulnerable client that uses a single aud = token_EP.\n\nI am not sure what you're trying to say here - that the alternative fix is only meant for clients that use single-valued `aud`? For which AS(s)? Or something entirely different?",
          "createdAt": "2025-04-08T08:08:05Z",
          "updatedAt": "2025-04-08T08:08:05Z"
        },
        {
          "author": "adon-at-work",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Let's not go line by line about my previous response. With due respect, I disagree your counterexample serves to invalidate a quick-and-dirty fix, which is meant to be a quick and dirty fix.\n\n---\n\nMore importantly, as a reader from the engineering world, if I read OIDC (specifically [section 9](https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication) and may be also RFC752x), and implemented everything there with AS accepting **only** token EP (note that there're no such Updates/Deprecates header on OIDC docs), I'll be happily declaring that I'm fully standard-compliant. It's unlikely I'd go look at CIBA and RFC9126 (PAR) until there's a need to support those extensions.\n\nAnd if we read the whole passages from CIBA and RFC9126(PAR) in their entirety, they both recognized there's ambiguity on `aud` value, and thus backward compatibility issues. People can always say I gotta balance resources/risk among priorities other than just security. Putting myself into the shoes of the opposing side, some will likely argue that they're NOT a normative change anyone has to follow or have followed, since (1) they have no Updates/Deprecates header for the older RFC/OIDC; (2) they can be interpreted as extension-specific; (3) the last \"MUST\" sentence that you quoted is also a conditional statement applicable to those who need/want to facilitate interoperability; and/or (4) the last sentence from CIBA and RFC9126 sound kinda incompatible with each other if I need to support both CIBA and RFC9126. It doesn't mean/matter if I, as a security folk, fully agree, that's just how the world works. You will understand as you enter the industry. :)\n\nFrom [CIBA](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html#auth_request)\n\n> Note that there's some potential ambiguity around the appropriate audience value to use when JWT client assertion based authentication is employed. To address that ambiguity the Issuer Identifier of the OP SHOULD be used as the value of the audience. To facilitate interoperability, the OP MUST accept its Issuer Identifier, Token Endpoint URL, or Backchannel Authentication Endpoint URL as values that identify it as an intended audience.\n\nFrom [RFC9126](https://datatracker.ietf.org/doc/html/rfc9126#section-2-5)\n\n> Due to historical reasons, there is potential ambiguity regarding the appropriate audience value to use when employing JWT client assertion-based authentication (defined in [Section 2.2](https://www.rfc-editor.org/rfc/rfc7523#section-2.2) of [[RFC7523](https://datatracker.ietf.org/doc/html/rfc7523)] with private_key_jwt or client_secret_jwt authentication method names per Section 9 of [[OIDC](http://openid.net/specs/openid-connect-core-1_0.html)]). To address that ambiguity, the issuer identifier URL of the authorization server according to [[RFC8414](https://datatracker.ietf.org/doc/html/rfc8414)] SHOULD be used as the value of the audience. In order to facilitate interoperability, the authorization server MUST accept its issuer identifier, token endpoint URL, or pushed authorization request endpoint URL as values that identify it as an intended audience.\n\nMy two cents. May be I'm wrong, BCP is BCP, technically it's not a standard. No matter what will be written, people might have different opinions on considering anything there as normative changes or not. Regardless, your contribution on writing up a useful BCP is valuable, if possible, take the chance to cleanup the mess. Give a comprehensive guide on how things can be best fixed, and leave no/less ambiguity so people can have excuses. And that's my perhaps naive belief. :)\n\nAnd so, just as a random reader (who'd appreciate a well-documented reference to use against Goliath :)), I'd love to see:\n- at least recognize the ambiguity like CIBA/RFC9126, so people know a client change from token_EP to something else may be a breaking change, since it does not guarantee server acceptance. If it just works, cool!\n- the BCP / most recommended `aud` value a client should send. conforming to CIBA and RFC9126, apparently should be the issuer.\n- the BCP for AS, what `aud` value should it accept? regardless of whether it's interpreted as normative or just a BCP recommendation. You probably want AS to accept only either issuer or target-specific endpoint URL. I'd argue making it target endpoint specific is never clearly spelled out by any other spec. For instance, PAR endpoint should not take aud=token_EP, and token_endpoint should not take aud=par_EP, unless for interoperability/historical reasons.\n- the BCP if just in case a client cannot get all your ASes to comply, then there comes recommendations in decreasing preference. 1. use different (the current draft uses the word \"fresh\") key material per AS; 2. ensure no overlapping of (client_id, aud) among all supported current and future ASes (unless absolutely required... it's okay to condition that), etc...\n\nThey're my little suggestions for you to consider and decide one way or the other. Thanks and appreciate that. :)",
          "createdAt": "2025-04-09T18:58:38Z",
          "updatedAt": "2025-04-10T22:58:19Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "I_kwDOOKn4ys6zhnK0",
      "title": "Make \"Updates to Mix-Up Attacks\" subsection more self-contained",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/18",
      "state": "OPEN",
      "author": "KevinLuo2000",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "(This is part of the feedback by @adon-at-work on #17, to be resolved by @KevinLuo2000)\n\n> My first impression after reading the first few sections in 2.2 is like it\u2019s written more like attacking RFC9700 4.4 line by line or as if presenting a diff for D Fett\u2019s considerations of updating his spec than targeting someone who has no knowledge about mix-up. The fact that I need to open two specs side-by-side will fail to gain any tractions from engineers IMO. The spec should be much more self-contained, and the requirements to click on a link is optional. It is extremely hard to follow, even for me. \n>\n> This new RFC draft implies that we\u2019re no more in the mentality of filing an errata to RFC9700 nor making last minute modification suggestions before RFC9700 was published. Your section 2.3 seems to be starting fresh with a new attack (even claiming a huge scope, as huge as \u201cAttacks in open ecosystems\u201d), which is good.",
      "createdAt": "2025-04-22T19:26:26Z",
      "updatedAt": "2025-04-22T20:06:31Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 19,
      "id": "I_kwDOOKn4ys6zhwVk",
      "title": "Clarify the application scenario and attack scenario of \"Open Ecosystems\"",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/19",
      "state": "OPEN",
      "author": "KevinLuo2000",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "(This is part of the feedback by @adon-at-work on https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/pull/17, to be resolved by @KevinLuo2000)\n\n**Condense Section 2.3.1 \"OAuth in Open Ecosystems\" and Section 2.3.2 \"Attack Scenario\":**\n\n> More generally, quite many content isn\u2019t written like a spec, but more like a blog/paper/story, and it will surprise those who come for a very cold BCP or a spec. Whether it\u2019s traditional/new, less barrier, and how open is irrelevant from spec perspective, they\u2019re more like market trends or just considerations for evaluating security risk/impact only. A link to perhaps a blog for such content (or a presentation talking about reversal) could be good, but they shouldn\u2019t be the main text of the spec. Those information, if absolutely relevant, should be compressed no more than 1 paragraph. I\u2019m afraid the more content you have, the harder it is to get consensus with a broad community. My point is less is better when drafting up the spec.\n\n**Clarify the scope of \"Open Ecosystems\":**\n\n> I have to also admit that I have a different opinion on DCR. May be I should not accuse it with \u201cno body using it\u201d or \u201cimpractical\u201d, when I lately figured the open-banking standard backed by UK gov has DCR standardized (99% similar to OAuth2 DCR as I briefly overviewed). Think about there\u2019s a universal banking app that works across all different (UK) banks. I assume a user can just go to such a universal banking app, choose let\u2019s say HSBC (which under the hood hits HSBC\u2019s DCR) or even directly specify any URL that conforms to the UK open-banking standard. Then the client negotiates some client credential for oauth client authentication, and subsequently launches auth code grant to authenticate the user too. \n> \n> I don\u2019t know whether we should classify it as open-ecosystem, where the app will then speak the same standardized banking protocols regardless of what bank resource servers are. May be they can support bank/issuer-sharing oauth scenarios since even a single user can have multiple bank accounts with a single bank. But it does have certain openness where a user can dynamically feed a new OAuth \u201cclient-configuration\u201d at will, and can face COAT attacks. \n> \n> I don\u2019t know how widely adopted that thing is, may be there\u2019s just some part of the world in EU we don\u2019t know enough. Let\u2019s just assume this existed, or may hypothetically exist in the future as a properly valid use case. Hence, I want AS-sharing to be described just as a characteristic by itself, instead of tiring it to and put it under a section of open-ecosystem. \n> \n> One line on AS-sharing, I think, is good and succinct enough to bring up the problem:\n> > AS-sharing. a client can use a (honest) AS, with multiple sets of different client credentials (e.g.., client id), for legitimate purposes.\n> \n",
      "createdAt": "2025-04-22T19:46:12Z",
      "updatedAt": "2025-04-22T19:46:12Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 20,
      "id": "I_kwDOOKn4ys6zhycn",
      "title": "Decide whether to include \"Client Configuration Confusion\"",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/20",
      "state": "OPEN",
      "author": "KevinLuo2000",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "(This is part of the feedback by @adon-at-work on #17, to be resolved by @KevinLuo2000)\n\n> I don\u2019t have a good idea how 2.3.4 should be structured, but I\u2019m very afraid that may stir up more debate as one may argue it shouldn\u2019t be as an OAuth protocol issue. For argument sake, it\u2019s more a resource server issue, or more like an issue of \u201copen-ecosystem\u201d where access token is given to a resource endpoint controlled by attacker. I want it in, as 2.3, like a section of its own, as I think it\u2019s valuable to the community, but hesitate that people might not be very receptive, and it may take a lot more battles to fight that section in.\n",
      "createdAt": "2025-04-22T19:51:03Z",
      "updatedAt": "2025-04-22T19:51:03Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 21,
      "id": "I_kwDOOKn4ys6zh1Kx",
      "title": "Restructure \"Mix-up Reloaded\"-related Sections",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/issues/21",
      "state": "OPEN",
      "author": "KevinLuo2000",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "(This is part of the feedback by @adon-at-work on #17, to be resolved by @KevinLuo2000)\n\n> With due respect, I recommend the following structure, with contents from 2.3.3 absorbed in appropriate sections.\n> \n> I suppose we should write it as a new attack, either we call it Advanced Mix-up Attacks (if you want to honor D Fett) or COAT and CORF Attacks, or even COAT and CORF (aka. Advanced mix-up). As you introduce it, may be we should just say this section 2.2 supersedes mix-up as defined in RFC9700 and/or we should frame there\u2019re n variants, and certain variants is covered by RFC9700.\n> \n> **2.2.1 Attack Description**\n> \u201cThe description here follows RFC9700 section 4.4 (kinda give credit to them), with new variants of the attack outlined below.\u201d\n> \n> Preconditions:\n> * copy presumptions that are still valid, probably we will use only the first one in 4.4\n> * **AS-sharing. a client can use a (honest) AS, with multiple sets of different client credentials (e.g.., client id), for legitimate purposes.** (RFC9700 implicitly assumed/implied otherwise. Just in case a client can guarantee uniqueness of AS, RFC9700 4.4 suffices\u2026 I assume this is true. If not, we may point to a discussion section.)\n> A final paragraph like \u201cHence this advanced mix-up requires less assumptions than the mixup in RFC9700.\u201d\n> And so we split the discussion into 2 subsections\n> \n> **2.2.1.1 Same redirect_uri**\n> Same as 4.4.1 + redirect_uri in the attack steps\n> Variants:\n> * Mix-Up with Interception. (same as 4.4.4.1) still copy their text\n> * Implicit Grant(same as 4.4.4.1) still copy their text\n> * OpenID Connect(same as 4.4.4.1) still copy their text\n> * Na\u00efve\u2026 or CORF (new)\n> * Whatever other new variant\n> \n> **2.2.1.2 Distinct redirect_uri**\n> Open this paragraph with why it can still fail, as opposed to understanding in RFC9700.\n> Same as 4.4.1 with distinct redirect_uri adjusted accordingly in attack steps\n> \n> Variants:\n> * Mix-Up with Interception. refer to 2.2.2.1\n> * Implicit Grant. refer to 2.2.2.1\n> * OpenID Connect. refer to 2.2.2.1\n> * Inherit other in 2.2.2.1\n> * Add any new, if any\n> \n> (new and old) Variants corresponding and unique to distinct redirect_uri.\n> \n> **2.2.2 Countermeasures.**\n> 2.2.2.1\n> When precondition 2 does not hold, or when client has enforced that the AS-sharing condition will NOT exist. One may refer to 4.4.2, except with the following cavets/updates\u2026\u2026 this is basically your draft. But please make those suggested defenses split also in bullet form that kinda correspond to Variant list (better if you can come up with a name for them instead of Variant 1,2,3).\n> \n> 2.2.2.2\n> Given precondition 2, 2.2.1.1 needs to change to use distinct redirect_uri, right?",
      "createdAt": "2025-04-22T19:56:57Z",
      "updatedAt": "2025-04-22T19:56:57Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 5,
      "id": "PR_kwDOOKn4ys6Pz3-x",
      "title": "Attack description for Audience Injection Attacks",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/pull/5",
      "state": "MERGED",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Closes #2 ",
      "createdAt": "2025-03-24T06:17:11Z",
      "updatedAt": "2025-03-24T16:07:12Z",
      "baseRepository": "SECtim/draft-wuertele-oauth-security-topics-update",
      "baseRefName": "main",
      "baseRefOid": "d698f037727d3a6d92acbbe4f763cb865c0cc9ad",
      "headRepository": "SECtim/draft-wuertele-oauth-security-topics-update",
      "headRefName": "aud_inj_attack_description_ph",
      "headRefOid": "05d09878a63bfc68461eb929a3722de5f8f1cf68",
      "closedAt": "2025-03-24T16:07:11Z",
      "mergedAt": "2025-03-24T16:07:11Z",
      "mergedBy": "PedramHD",
      "mergeCommit": {
        "oid": "150a5567dde5ecd6a4430b73ff294f5c853964f9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOOKn4ys6hkZs9",
          "commit": {
            "abbreviatedOid": "05d0987"
          },
          "author": "PedramHD",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-24T14:52:16Z",
          "updatedAt": "2025-03-24T14:52:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 6,
      "id": "PR_kwDOOKn4ys6P-9zB",
      "title": "Audience Injection Countermeasures",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/pull/6",
      "state": "MERGED",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [
        "PedramHD"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2025-03-25T06:11:32Z",
      "updatedAt": "2025-03-25T10:11:26Z",
      "baseRepository": "SECtim/draft-wuertele-oauth-security-topics-update",
      "baseRefName": "main",
      "baseRefOid": "150a5567dde5ecd6a4430b73ff294f5c853964f9",
      "headRepository": "SECtim/draft-wuertele-oauth-security-topics-update",
      "headRefName": "aud_inj_countermeasures_tiw",
      "headRefOid": "7f84fdc3550ad850b9c042bcc6ef65f7f04cd741",
      "closedAt": "2025-03-25T10:11:26Z",
      "mergedAt": "2025-03-25T10:11:26Z",
      "mergedBy": "PedramHD",
      "mergeCommit": {
        "oid": "8b07a975b10da6081d50b0b040adb3013e83ed4a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOOKn4ys6ht1-7",
          "commit": {
            "abbreviatedOid": "7f84fdc"
          },
          "author": "PedramHD",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-25T10:09:21Z",
          "updatedAt": "2025-03-25T10:09:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 7,
      "id": "PR_kwDOOKn4ys6QRyqR",
      "title": "minor touch up",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/pull/7",
      "state": "MERGED",
      "author": "adon-at-work",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I'm Adonis, one of the co-authors for the COAT and CORF work.\r\n\r\nThis audience injection attack is an interesting one. While reviewing what you guys have prepared for updating RFC9700, I spotted some non-controversial improvements as follows.\r\n\r\nI have other comments and questions regarding the attack and defense too, using my lens from both the academia and industry perspectives. I know Kaixuan is arranging a meeting between all of us, and we will discuss them. :)",
      "createdAt": "2025-03-26T22:17:10Z",
      "updatedAt": "2025-03-27T22:25:11Z",
      "baseRepository": "SECtim/draft-wuertele-oauth-security-topics-update",
      "baseRefName": "main",
      "baseRefOid": "8b07a975b10da6081d50b0b040adb3013e83ed4a",
      "headRepository": "adon-at-work/draft-wuertele-oauth-security-topics-update",
      "headRefName": "patch-1",
      "headRefOid": "1008401e47de198e0f5b080c7e8fbdedfa6588ec",
      "closedAt": "2025-03-27T22:12:39Z",
      "mergedAt": "2025-03-27T22:12:38Z",
      "mergedBy": "SECtim",
      "mergeCommit": {
        "oid": "63c6bb01cc01bc7cb4002846328ae57a267b8920"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOOKn4ys6iI6xa",
          "commit": {
            "abbreviatedOid": "982fa5c"
          },
          "author": "SECtim",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for taking the time to read through the proposed text and for improving it!",
          "createdAt": "2025-03-27T08:15:49Z",
          "updatedAt": "2025-03-27T08:16:49Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Unfortunately, this cannot be `json`, because that leads to errors in the build pipeline (complaining that this is not valid JSON, which is true). We consciously decided not to omit the `...`  to clearly indicate that further metadata is needed.",
              "createdAt": "2025-03-27T08:15:49Z",
              "updatedAt": "2025-03-27T08:17:11Z"
            },
            {
              "originalPosition": 14,
              "body": "See above.",
              "createdAt": "2025-03-27T08:15:57Z",
              "updatedAt": "2025-03-27T08:16:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOKn4ys6iUBmL",
          "commit": {
            "abbreviatedOid": "101491b"
          },
          "author": "SECtim",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-27T19:13:01Z",
          "updatedAt": "2025-03-27T19:13:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOOKn4ys6iUPPA",
          "commit": {
            "abbreviatedOid": "101491b"
          },
          "author": "PedramHD",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-27T19:40:41Z",
          "updatedAt": "2025-03-27T19:40:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 14,
      "id": "PR_kwDOOKn4ys6RfYTK",
      "title": "Clarify that none of the current countermeasures require AS changes",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/pull/14",
      "state": "MERGED",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Do we need to explicitly explain why an AS change (e.g., to only accept its issuer identifier) does not help at all in preventing the attacks?\r\n\r\nFixes #12",
      "createdAt": "2025-04-05T06:14:18Z",
      "updatedAt": "2025-04-28T13:55:02Z",
      "baseRepository": "SECtim/draft-wuertele-oauth-security-topics-update",
      "baseRefName": "main",
      "baseRefOid": "f9ff75120236075925338e7a366b168b5d4f13cf",
      "headRepository": "SECtim/draft-wuertele-oauth-security-topics-update",
      "headRefName": "fix_12",
      "headRefOid": "9f0f4ddf7bd7f3659b965bc47fa2ceb670cd9ffd",
      "closedAt": "2025-04-28T13:55:02Z",
      "mergedAt": "2025-04-28T13:55:02Z",
      "mergedBy": "PedramHD",
      "mergeCommit": {
        "oid": "6938a933310a9677d05bea44fcf77d8d444c9bad"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOOKn4ys6jyseW",
          "commit": {
            "abbreviatedOid": "9f0f4dd"
          },
          "author": "adon-at-work",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-07T20:00:55Z",
          "updatedAt": "2025-04-07T20:01:18Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Based on Section 4.1.3 of RFC7519, the very generic clause of how `aud` can be used, it sounds like you're saying the authorization servers are expected to **readily** accept `aud={issuer}`, `aud={token_endpoint}`, `aud={revoke_endpoint}`, `aud={par_endpoint}` etc that identify themselves. Is this realistic though, when most other specs were suggesting clients to send `aud={token_endpoint}`?\r\n\r\nMy two cents. Think about I'm building a client that wants to support 3 servers. It's always better to define a clear (and standardized) contract between clients and servers. A client then needs to not to maintain a map like serverA can only take `token_endpoint`, while server B&C accept only `issuer` (nowhere this is communicated through openid/oauth metadata??).",
              "createdAt": "2025-04-07T20:00:55Z",
              "updatedAt": "2025-04-07T20:14:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOKn4ys6j3Y6L",
          "commit": {
            "abbreviatedOid": "9f0f4dd"
          },
          "author": "SECtim",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-08T08:55:11Z",
          "updatedAt": "2025-04-08T08:55:11Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "From a (pure) spec perspective, the AS is ready to accept these values due to the very generic language in RFC 7519. For some endpoints like PAR and CIBA, that's also explicitly required by the respective specs (see the discussion in #13). I.e., there are no _normative_ changes to the AS, which is what the current text says.\r\n\r\nThat said (and taking into consideration the engineer perspective): What is your proposal? Should the text explicitly say that even though there as no normative changes, a concrete AS implementation may need to be adapted? Or are you suggesting to make normative changes, i.e., _requiring_ as AS to (only?) accept its issuer identifier and/or the exact endpoint as `aud`, even though that's not strictly necessary to prevent the attack?\r\n\r\n> It's always better to define a clear (and standardized) contract between clients and servers. A client then needs to not to maintain a map like serverA can only take token_endpoint, while server B&C accept only issuer\r\n\r\nThe current text actually does this (albeit not in a normative way) - it basically says: If you as a client use Discovery/AS Metadata with that AS, then use the issuer identifier; otherwise, use the exact endpoint URI (as the sole `aud` value in both cases). The AS can safely accept both (or, for example, require its clients to always use AS Metadata, and hence, the issuer identifier, as is the case, e.g., for FAPI 2.0 SP).\r\n\r\nDo you propose to make this distinction (AS Metadata/Discovery => Issuer Identifier; otherwise => exact endpoint) an explicit normative requirement?\r\nWe tried to avoid that to leave ecosystems the option to, e.g., always use the issuer identifier, even if they don't use AS Metadata/Discovery (in which case the client needs to validate the \"issuer identifier to endpoints\" mapping out of band, but getting AS information out of band, e.g., by configuration, is a common practice anyway; and the language in #15 clearly requires clients to actually validate this mapping).\r\nNote that leaving this option open is also necessary to not create a conflict with the OAuth WG's 7523-bis draft and the current text for an OIDC errata that require clients to use the issuer identifier (regardless of whether the AS Metadata/Discovery mechanism is used).\r\n\r\n>  (nowhere this is communicated through openid/oauth metadata??).\r\n\r\nTrue, it currently isn't and never was - this problem isn't new. Actually, this is another reason for expecting that many of the ASs that rely on clients getting all required metadata via AS Metadata/Discovery will already be pretty liberal in what they accept as `aud`.",
              "createdAt": "2025-04-08T08:55:11Z",
              "updatedAt": "2025-04-08T08:55:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOKn4ys6m21wq",
          "commit": {
            "abbreviatedOid": "9f0f4dd"
          },
          "author": "PedramHD",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-28T13:54:23Z",
          "updatedAt": "2025-04-28T13:54:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 15,
      "id": "PR_kwDOOKn4ys6RffU5",
      "title": "Require clients to validate the issuer identifier",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/pull/15",
      "state": "MERGED",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Also, better describe the difference to the \"issuer\" in RFC 9700.\r\n\r\nFixes #10",
      "createdAt": "2025-04-05T06:37:29Z",
      "updatedAt": "2025-04-28T13:59:02Z",
      "baseRepository": "SECtim/draft-wuertele-oauth-security-topics-update",
      "baseRefName": "main",
      "baseRefOid": "f9ff75120236075925338e7a366b168b5d4f13cf",
      "headRepository": "SECtim/draft-wuertele-oauth-security-topics-update",
      "headRefName": "fix_10",
      "headRefOid": "a20f0032e69b0b5bc0e494a0e583322763bdddc7",
      "closedAt": "2025-04-28T13:59:02Z",
      "mergedAt": "2025-04-28T13:59:02Z",
      "mergedBy": "PedramHD",
      "mergeCommit": {
        "oid": "98ba90c9a9c1e7c957c3f34c67e4a00b49dd976f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOOKn4ys6jywD7",
          "commit": {
            "abbreviatedOid": "ca7cef7"
          },
          "author": "adon-at-work",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-07T20:06:28Z",
          "updatedAt": "2025-04-07T20:06:29Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Clients ~they~ MUST retrieve",
              "createdAt": "2025-04-07T20:06:29Z",
              "updatedAt": "2025-04-07T20:06:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOKn4ys6j241Z",
          "commit": {
            "abbreviatedOid": "ca7cef7"
          },
          "author": "SECtim",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-08T08:09:54Z",
          "updatedAt": "2025-04-08T08:09:55Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Good catch! Thanks!",
              "createdAt": "2025-04-08T08:09:54Z",
              "updatedAt": "2025-04-08T08:09:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOKn4ys6m25ZY",
          "commit": {
            "abbreviatedOid": "a20f003"
          },
          "author": "PedramHD",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-28T13:58:38Z",
          "updatedAt": "2025-04-28T13:58:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 16,
      "id": "PR_kwDOOKn4ys6Rfiei",
      "title": "Explain why clients regularly use the token EP as audience",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/pull/16",
      "state": "MERGED",
      "author": "SECtim",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #8",
      "createdAt": "2025-04-05T07:04:09Z",
      "updatedAt": "2025-04-28T14:05:33Z",
      "baseRepository": "SECtim/draft-wuertele-oauth-security-topics-update",
      "baseRefName": "main",
      "baseRefOid": "f9ff75120236075925338e7a366b168b5d4f13cf",
      "headRepository": "SECtim/draft-wuertele-oauth-security-topics-update",
      "headRefName": "fix_8",
      "headRefOid": "4e2708494311ef9b35031d9b01359938d24b61bc",
      "closedAt": "2025-04-28T14:05:32Z",
      "mergedAt": "2025-04-28T14:05:32Z",
      "mergedBy": "PedramHD",
      "mergeCommit": {
        "oid": "30f3313b338b3482190f7eb21f2c40bd40180461"
      },
      "comments": [
        {
          "author": "adon-at-work",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks",
          "createdAt": "2025-04-07T20:04:51Z",
          "updatedAt": "2025-04-07T20:04:51Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOOKn4ys6m2_LD",
          "commit": {
            "abbreviatedOid": "4e27084"
          },
          "author": "PedramHD",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-28T14:05:16Z",
          "updatedAt": "2025-04-28T14:05:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 17,
      "id": "PR_kwDOOKn4ys6TE0Hf",
      "title": "First draft of Mix-up Reloaded Work",
      "url": "https://github.com/SECtim/draft-wuertele-oauth-security-topics-update/pull/17",
      "state": "OPEN",
      "author": "KevinLuo2000",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Resolves #3.\r\n\r\nPreview: https://kevinluo2000.github.io/TestIETF/draft-wuertele-oauth-security-topics-update.html\r\n\r\nCurrently, I separated the mix-up updates that are open ecosystem-agnostic (Section 2.2) from those that have to do with the open ecosystem/issuer-sharing setting (Section 2.3.1-2.3.3), and added a preliminary draft on the newly-developed RS mix-up idea (Section 2.3.4, now referred to as \u201cClient Configuration Confusion Attack\u201d).\r\n\r\nThe contents are based on:\r\n\r\n- Our original proposed updates to IETF [Dec 2024-Jan 2025]\r\n- Feedback from Aaron, Daniel, Guido, and others at OAuth Security Workshop [Feb 2025]\r\n    - Especially, clearly define what constitutes an integrated \u201capp\u201d, and use an alternative term to avoid the confusion with what an \u201capplication\u201c usually stands for in OAuth\r\n- Follow-up discussions (mainly with @SECtim) in the OAuth Security Workshop\u2019s \\#mix-up-attacks Slack channel [Mar-Apr 2025]\r\nas well as invaluable insights/feedback from one-on-one discussions/group meeting with @adon-at-work @SECtim @PedramHD , and my research group.\r\n\r\nNote that I still have some unresolved comments from @adon-at-work side, regarding the structure and writing style. I will post them as GitHub issues and start resolving them in the upcoming days.",
      "createdAt": "2025-04-18T06:06:35Z",
      "updatedAt": "2025-05-05T09:33:35Z",
      "baseRepository": "SECtim/draft-wuertele-oauth-security-topics-update",
      "baseRefName": "main",
      "baseRefOid": "6f69cf88e001293e53f2e88d103f4cbf1646788a",
      "headRepository": "KevinLuo2000/draft-wuertele-oauth-security-topics-update",
      "headRefName": "main",
      "headRefOid": "af5c9799561f80f91a3eb65a08fbad58ccaa6923",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}